<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Pathfinder</name>
    </assembly>
    <members>
        <member name="M:Pathfinder.Event.EventManager.RegisterListener(System.Type,System.Action{Pathfinder.Event.PathfinderEvent},System.String)">
            <summary>
            Registers an event listener by runtime type.
            </summary>
            <param name="pathfinderEventType">The PathfinderEvent Runtime Type to register for</param>
            <param name="listener">The listener function that will be executed on an event call</param>
            <param name="debugName">Name to assign for debug purposes</param>
        </member>
        <member name="M:Pathfinder.Event.EventManager.RegisterListener``1(System.Action{``0},System.String,System.Nullable{System.Int32})">
            <summary>
            Registers an event listener by compile time type.
            </summary>
            <param name="listener">The listener function that will be executed on an event call</param>
            <param name="debugName">Name to assign for debug purposes</param>
            <typeparam name="T">The PathfinderEvent Compile time Type to listen for</typeparam>
        </member>
        <member name="M:Pathfinder.Event.EventManager.UnregisterListener(System.Type,System.Action{Pathfinder.Event.PathfinderEvent})">
            <summary>
            Removes an event listener by runtime type.
            </summary>
            <param name="pathfinderEventType">The PathfinderEvent Runtime Type to remove for</param>
            <param name="listener">The listener function to remove</param>
        </member>
        <member name="M:Pathfinder.Event.EventManager.UnregisterListener``1(System.Action{``0})">
            <summary>
            Removes an event listener by compile time type.
            </summary>
            <param name="listener">The listener function to remove</param>
            <typeparam name="T">The PathfinderEvent Compile time Type to remove for</typeparam>
        </member>
        <member name="M:Pathfinder.Event.EventManager.CallEvent(Pathfinder.Event.PathfinderEvent)">
            <summary>
            Calls a PathfinderEvent.
            </summary>
            <param name="pathfinderEvent">The PathfinderEvent to call.</param>
        </member>
        <member name="P:Pathfinder.Pathfinder.LoadedModIdentifiers">
            <summary>
            Gets the loaded mod identifiers.
            </summary>
            <value>The loaded mod identifiers.</value>
        </member>
        <member name="P:Pathfinder.Pathfinder.UnloadedModIdentifiers">
            <summary>
            Gets the unloaded mod identifiers.
            </summary>
            <value>The  mod identifiers.</value>
        </member>
        <member name="M:Pathfinder.Pathfinder.IsModLoaded(System.String)">
            <summary>
            Determines whether a mod is loaded
            </summary>
            <returns><c>true</c>, if mod is loaded, <c>false</c> otherwise.</returns>
            <param name="id">Mod Identifier.</param>
        </member>
        <member name="M:Pathfinder.Pathfinder.IsModIdentifierValid(System.String,System.Boolean)">
            <summary>
            Determines whether a mod identifier is valid
            </summary>
            <returns><c>true</c>, if mod identifier is valid, <c>false</c> otherwise.</returns>
            <param name="id">The Mod Identifier.</param>
            <param name="shouldThrowReason">If set to <c>true</c> then this method will throw.</param>
        </member>
        <member name="T:Pathfinder.PathfinderHooks">
            <summary>
            Function hooks for the Pathfinder mod system
            </summary>
            Place all functions to be hooked into Hacknet here
        </member>
        <member name="M:Pathfinder.Executable.Interface.DrawOutline(Pathfinder.Executable.Instance)">
            <summary>
            Draws the outline.
            </summary>
            <returns><c>true</c>, if vanilla outline draw should continue, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Pathfinder.Executable.Interface.DrawTarget(Pathfinder.Executable.Instance,System.String)">
            <summary>
            Draws the target.
            </summary>
            <returns><c>true</c>, if vanilla target draw should continue, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Pathfinder.Executable.Interface.Update(Pathfinder.Executable.Instance,System.Single)">
            <summary>
            Runs an update tick for the executable
            </summary>
            <returns>Whether isExiting should be set to true or not (thus exiting the program), null doesn't set it</returns>
        </member>
        <member name="M:Pathfinder.Executable.Base.DrawOutline(Pathfinder.Executable.Instance)">
            <summary>
            Draws the outline.
            </summary>
            <returns><c>true</c>, if vanilla outline draw should continue, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Pathfinder.Executable.Base.DrawTarget(Pathfinder.Executable.Instance,System.String)">
            <summary>
            Draws the target.
            </summary>
            <returns><c>true</c>, if vanilla target draw should continue, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Pathfinder.Executable.Base.Update(Pathfinder.Executable.Instance,System.Single)">
            <summary>
            Runs an update tick for the executable
            </summary>
            <returns>Whether isExiting should be set to true or not (thus exiting the program), null doesn't set it</returns>
        </member>
        <member name="M:Pathfinder.Executable.Handler.RegisterExecutable(System.String,Pathfinder.Executable.Interface)">
            <summary>
            Adds an executable interface by id.
            </summary>
            <returns>The full mod id if added to the game, <c>null</c> otherwise.</returns>
            <param name="id">The Executable Identifier to try and add.</param>
            <param name="inter">The interface object.</param>
        </member>
        <member name="M:Pathfinder.Executable.Handler.GenerateFileDataString(System.String,System.String,System.String)">
            <summary>
            Generates a file data string for inputs.
            </summary>
            <returns>The resulting file data string.</returns>
            <param name="assemblyName">The Assembly's Name.</param>
            <param name="typeFullname">The Type's FullName value.</param>
            <param name="id">The current mod's Identifier.</param>
        </member>
        <member name="M:Pathfinder.Executable.Handler.UnregisterExecutable(System.String)">
            <summary>
            Removes an executable by it's id
            </summary>
            <param name="id">The full id of the executable</param>
            <returns>If successful</returns>
        </member>
        <member name="M:Pathfinder.Executable.Handler.IsFileDataForModExe(System.String)">
            <summary>
            Determines whether the file data is for a mod interface.
            </summary>
            <returns><c>true</c>, if the file data is for a mod interface, <c>false</c> otherwise.</returns>
            <param name="fileData">The Filedata to check against.</param>
        </member>
        <member name="M:Pathfinder.Executable.Handler.GetStandardFileDataBy(System.String,System.Boolean)">
            <summary>
            Gets the standard file data by id.
            </summary>
            <returns>The standard file data or <c>null</c> if it doesn't exist.</returns>
            <param name="id">Executable Identifier.</param>
            <param name="requiresModId">If set to <c>true</c> id requires a prefixing mod identifier delimated by period.</param>
        </member>
        <member name="M:Pathfinder.Executable.Handler.GetStandardFileDataBy(Pathfinder.Executable.Interface)">
            <summary>
            Gets the first standard file data by interface.
            </summary>
            <returns>The standard file data or <c>null</c> if it doesn't exist.</returns>
            <param name="inter">The Executable Interface</param>
        </member>
        <member name="M:Pathfinder.Command.Handler.RegisterCommand(System.String,Pathfinder.Command.Handler.CommandFunc,System.String,System.Boolean)">
            <summary>
            Adds a command to the game.
            </summary>
            <returns>The full mod command id if added to the game, <c>null</c> otherwise</returns>
            <param name="key">The key used to run the command.</param>
            <param name="function">The function run when command is input.</param>
            <param name="description">A description to input when help is command is run (if not null).</param>
            <param name="autoComplete">If set to <c>true</c> then autocomplete for command is enabled.</param>
        </member>
        <member name="P:Pathfinder.Command.Help.PageCount">
            <summary>
            Gets the help page count.
            </summary>
            <value>The help page count.</value>
        </member>
        <member name="M:Pathfinder.Command.Help.GetStringFor(System.String)">
            <summary>
            Gets the help string for a command.
            </summary>
            <returns>The resulting help string or <c>null</c> if it doesn't exist.</returns>
            <param name="cmd">The Command key.</param>
        </member>
        <member name="M:Pathfinder.Command.Help.GetPageString(System.Int32)">
            <summary>
            Gets the help string for a page.
            </summary>
            <returns>The string for a page.</returns>
            <param name="page">The page to get the string for.</param>
        </member>
        <member name="M:Pathfinder.Daemon.Handler.RegisterDaemon(System.String,Pathfinder.Daemon.Interface)">
            <summary>
            Registers a daemon interface.
            </summary>
            <returns>The daemon's full id if added to the game, <c>null</c> otherwise.</returns>
            <param name="id">The daemon interface id to insert.</param>
            <param name="inter">The interface to add.</param>
        </member>
        <member name="P:Pathfinder.Util.ExeInfoManager.ExecutableInfo.PortNumber">
            <summary>
            Gets the port number for the info.
            </summary>
        </member>
        <member name="P:Pathfinder.Util.ExeInfoManager.ExecutableInfo.Number">
            <summary>
            Gets the number within <see cref="F:Hacknet.PortExploits.exeNums"/>.
            </summary>
        </member>
        <member name="P:Pathfinder.Util.ExeInfoManager.ExecutableInfo.NumberIndex">
            <summary>
            Gets the index within <see cref="F:Hacknet.PortExploits.exeNums"/>.
            </summary>
        </member>
        <member name="P:Pathfinder.Util.ExeInfoManager.ExecutableInfo.Name">
            <summary>
            Gets the executable name.
            </summary>
        </member>
        <member name="P:Pathfinder.Util.ExeInfoManager.ExecutableInfo.ServiceName">
            <summary>
            Gets the name of the port service.
            </summary>
        </member>
        <member name="P:Pathfinder.Util.ExeInfoManager.ExecutableInfo.NeedsPort">
            <summary>
            Gets a value indicating whether this <see cref="T:Pathfinder.Util.ExeInfoManager.ExecutableInfo"/> needs port.
            </summary>
            <value><c>true</c> if needs port; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Pathfinder.Util.ExeInfoManager.ExecutableInfo.Data">
            <summary>
            Gets the standard game data for the executable.
            </summary>
        </member>
        <member name="P:Pathfinder.Util.ExeInfoManager.ExecutableInfo.LocalData">
            <summary>
            Gets the local game data for the executable.
            </summary>
        </member>
        <member name="P:Pathfinder.Util.ExeInfoManager.ExecutableInfo.IsEmpty">
            <summary>
            Gets a value indicating whether this <see cref="T:Pathfinder.Util.ExeInfoManager.ExecutableInfo"/> is empty.
            </summary>
            <value><c>true</c> if is empty; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Pathfinder.Util.Utility.Array`1">
            <summary>
            Type specific Array Utilities
            </summary>
        </member>
        <member name="F:Pathfinder.Util.Utility.Array`1.Empty">
            <summary>
            An Empty Array of T
            </summary>
        </member>
        <member name="M:Pathfinder.Util.Utility.ConvertToValidXmlAttributeName(System.String)">
            <summary>
            Converts the input to a valid xml attribute name.
            </summary>
            <returns>A valid xml attribute name.</returns>
            <param name="input">Input to convert.</param>
        </member>
        <member name="P:Pathfinder.Util.Utility.ActiveModId">
            <summary>
            Gets the active mod's identifier.
            </summary>
            <value>The active mod identifier or Pathfinder if there is no active mod.</value>
        </member>
        <member name="M:Pathfinder.Util.Utility.GetId(System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Retrieves an identifier for the input.
            </summary>
            <returns>The resulting identifier.</returns>
            <param name="inputId">Input identifier.</param>
            <param name="ignorePeriod">If set to <c>true</c> ignore period.</param>
            <param name="ignoreValidXml">If set to <c>true</c> ignore valid xml.</param>
        </member>
        <member name="P:Pathfinder.Util.Utility.ClientOS">
            <summary>
            Gets the current client OS.
            </summary>
            <returns>The client's current OS.</returns>
        </member>
        <member name="P:Pathfinder.Util.Utility.ClientComputer">
            <summary>
            Gets the current client's Computer.
            </summary>
            <returns>The client's Current Computer.</returns>
        </member>
        <member name="P:Pathfinder.Util.Utility.ClientNetworkMap">
            <summary>
            Gets the current client's NetworkMap for the current client OS.
            </summary>
            <returns>The client's current Network Map.</returns>
        </member>
        <member name="M:Pathfinder.Util.Utility.GetCurrentComputer(Hacknet.OS)">
            <summary>
            Gets the current Computer the OS is active in.
            </summary>
            <returns>The currently active Computer.</returns>
            <param name="os">The OS to get the current Computer, or equal to <see cref="P:Pathfinder.Util.Utility.ClientOS"/> if <c>null</c>.</param>
        </member>
        <member name="P:Pathfinder.Util.Utility.CurrentComputer">
            <summary>
            Gets the current Computer the client is connected to.
            </summary>
            <value>The current Computer.</value>
        </member>
        <member name="M:Pathfinder.Util.Utility.DecimalToArbitrarySystem(System.Int64,System.Int32)">
            <summary>
            Converts the given decimal number to the numeral system with the
            specified radix (in the range [2, 36]).
            </summary>
            <param name="decimalNumber">The number to convert.</param>
            <param name="radix">The radix of the destination numeral system (in the range [2, 36]).</param>
            <returns></returns>
        </member>
        <member name="M:Pathfinder.Util.Utility.ArbitraryToDecimalSystem(System.String,System.Int32)">
            <summary>
            Converts the given number from the numeral system with the specified
            radix (in the range [2, 36]) to decimal numeral system.
            </summary>
            <param name="number">The arbitrary numeral system number to convert.</param>
            <param name="radix">The radix of the numeral system the given number
            is in (in the range [2, 36]).</param>
            <returns></returns>
        </member>
        <member name="T:Pathfinder.Util.Logger.LogLevel">
            <summary>
            Log Levels for the Logger
            </summary>
        </member>
        <member name="P:Pathfinder.Util.Logger.IncludeModId">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Pathfinder.Util.Logger"/> should include mod identifier.
            </summary>
            <value><c>true</c> if mod identifier should be included; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Pathfinder.Util.Logger.LogHistory">
            <summary>
            Gets the log history.
            </summary>
            <value>The log history for the past 100 log calls.</value>
        </member>
        <member name="M:Pathfinder.Util.Logger.AddFlag(Pathfinder.Util.Logger.LogLevel)">
            <summary>
            Adds flag(s) to this <see cref="T:Pathfinder.Util.Logger"/>'s flags.
            </summary>
            <param name="levels">Log Level(s) to add.</param>
        </member>
        <member name="M:Pathfinder.Util.Logger.SetFlags(Pathfinder.Util.Logger.LogLevel)">
            <summary>
            Sets showFlags to exact levels.
            </summary>
            <param name="levels">Log Levels to set this <see cref="T:Pathfinder.Util.Logger"/>'s showFlags to.</param>
        </member>
        <member name="M:Pathfinder.Util.Logger.RemoveFlag(Pathfinder.Util.Logger.LogLevel)">
            <summary>
            Removes a flag(s) from this <see cref="T:Pathfinder.Util.Logger"/>'s flags.
            </summary>
            <param name="levels">Log Level(s) to remove.</param>
        </member>
        <member name="M:Pathfinder.Util.Logger.HasFlag(Pathfinder.Util.Logger.LogLevel)">
            <summary>
            Determines whether this <see cref="T:Pathfinder.Util.Logger"/> has the flag(s).
            </summary>
            <returns><c>true</c>, has flag, <c>false</c> otherwise.</returns>
            <param name="level">Log Level(s) to test for.</param>
        </member>
        <member name="M:Pathfinder.Util.Logger.Log(Pathfinder.Util.Logger.LogLevel,System.Object[])">
            <summary>
            Logs the specified level and input.
            </summary>
            <param name="level">Log Level to log for.</param>
            <param name="input">Any stringable inputs. (if larger then one, must be in standard C# String.Format format)</param>
        </member>
        <member name="M:Pathfinder.Util.Logger.Verbose(System.Object[])">
            <summary>
            Logs on <see cref="T:Pathfinder.Util.Logger.LogLevel.VERBOSE"/> the specified input.
            </summary>
            <param name="input">Any stringable inputs. (if larger then one, must be in standard C# String.Format format)</param>
        </member>
        <member name="M:Pathfinder.Util.Logger.Debug(System.Object[])">
            <summary>
            Logs on <see cref="T:Pathfinder.Util.Logger.LogLevel.DEBUG"/> the specified input.
            </summary>
            <param name="input">Any stringable inputs. (if larger then one, must be in standard C# String.Format format)</param>
        </member>
        <member name="M:Pathfinder.Util.Logger.Info(System.Object[])">
            <summary>
            Logs on <see cref="T:Pathfinder.Util.Logger.LogLevel.INFO"/> the specified input.
            </summary>
            <param name="input">Any stringable inputs. (if larger then one, must be in standard C# String.Format format)</param>
        </member>
        <member name="M:Pathfinder.Util.Logger.Warn(System.Object[])">
            <summary>
            Logs on <see cref="T:Pathfinder.Util.Logger.LogLevel.WARN"/> the specified input.
            </summary>
            <param name="input">Any stringable inputs. (if larger then one, must be in standard C# String.Format format)</param>
        </member>
        <member name="M:Pathfinder.Util.Logger.Error(System.Object[])">
            <summary>
            Logs on <see cref="T:Pathfinder.Util.Logger.LogLevel.ERROR"/> the specified input.
            </summary>
            <param name="input">Any stringable inputs. (if larger then one, must be in standard C# String.Format format)</param>
        </member>
        <member name="M:Pathfinder.Util.Logger.Fatal(System.Object[])">
            <summary>
            Logs on <see cref="T:Pathfinder.Util.Logger.LogLevel.FATAL"/> the specified input.
            </summary>
            <param name="input">Any stringable inputs. (if larger then one, must be in standard C# String.Format format)</param>
        </member>
        <member name="T:Pathfinder.Util.ConvertAny">
            <summary>
            Extended conversion utilities to convert any type to any other type provided the conversion is valid.
            </summary>
        </member>
        <member name="M:Pathfinder.Util.ConvertAny.#cctor">
            <summary>
            Initializes static members of the <see cref="T:Pathfinder.Util.ConvertAny"/> class.
            </summary>
        </member>
        <member name="M:Pathfinder.Util.ConvertAny.CanConvert``1(System.Object)">
            <summary>
            Determines whether this instance can convert the specified value.
            </summary>
            <typeparam name="ToType">The type of to type.</typeparam>
            <param name="value">From value.</param>
            <returns><c>true</c> if this instance can convert the specified from value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Pathfinder.Util.ConvertAny.CanConvert(System.Type,System.Type)">
            <summary>
            Determines whether this instance can convert the specified <paramref name="fromType"/> to the <paramref name="toType"/>.
            </summary>
            <param name="fromType">From type.</param>
            <param name="toType">To type.</param>
            <returns><c>true</c> if the conversion is valid; otherwise, <c>false</c>.</returns>
            <remarks>
            This method checks 4 types of conversions:
            
            1. If they are the same type, returns true.
            2. If they are both IConvertible types, return true.
            3. If the toType is part of the inheritance chain of fromType.
            4. Direct casting, only returns true if both types have default constructors.
            </remarks>
        </member>
        <member name="M:Pathfinder.Util.ConvertAny.TryConvert``1(System.Object,``0@)">
            <summary>
            Attempts to convert the value to the specified type. 
            </summary>
            <typeparam name="ToType">The type to convert to.</typeparam>
            <param name="value">Value to convert.</param>
            <param name="toValue">Converted value.</param>
            <returns><c>true</c> if conversion succeeds, <c>false</c> otherwise.</returns>
            <remarks>
            If the conversion fails, the value of <paramref name="toValue"/> is the default
            of that particular type.
            </remarks>
        </member>
        <member name="M:Pathfinder.Util.ConvertAny.Convert``1(System.Object)">
            <summary>
            Converts the specified from value.
            </summary>
            <typeparam name="ToType">The type to convert to.</typeparam>
            <param name="fromValue">The value to convert.</param>
            <returns>Converted value.</returns>
            <exception cref="T:System.InvalidCastException">Raised when the value cannot be converted to the specified type.</exception>
        </member>
        <member name="M:Pathfinder.Util.ConvertAny.ConvertByType(System.Object,System.Type)">
            <summary>
            Converts value to the specified type.
            </summary>
            <param name="fromValue">The value to convert.</param>
            <param name="toType">The type to convert to.</param>
            <returns>Object that represents the converted type.</returns>
        </member>
        <member name="M:Pathfinder.Util.ConvertAny.Default``1">
            <summary>
            Creates a default instance of <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Type to create a default instance of.</typeparam>
            <returns>Default instance of <typeparamref name="T"/>.</returns>
            <remarks>
            For primitive types this will create a value of 0 with the specified type. For
            objects, if the object has a default constructor it will return a default instance
            of the type. If the object does not have a default constructor, it will return
            null.
            </remarks>
        </member>
        <member name="M:Pathfinder.Util.ConvertAny.DefaultByType(System.Type)">
            <summary>
            Creates a default instance of <paramref name="type"/>.
            </summary>
            <param name="type">The type.</param>
            <returns>Instance of the specified type.</returns>
            <remarks>
            This method uses the generic <see cref="M:Pathfinder.Util.ConvertAny.Default``1"/> method to create an instance
            of the type.
            </remarks>
        </member>
        <member name="T:Pathfinder.Util.Attribute.AllowOrderUnloadAttribute">
            <summary>
            Allow order unload attribute for allowing load order to be responsible for unloading the mod.
            </summary>
        </member>
        <member name="T:Pathfinder.Util.Attribute.ModOptionsAttribute">
            <summary>
            Mod options attribute which allows assignment of a derived <see cref="T:Pathfinder.GUI.ModOptions.AbstractOptions"/> class for a mod.
            </summary>
        </member>
        <member name="M:Pathfinder.Util.Locale.Get(System.String,System.Object[])">
            <summary>
            Retrieves the localized formatted (based on the extra arguments) string of the input along.
            </summary>
            <returns>The localized formatted string of the input, otherwise defaulting to LocaleTerms.Loc.</returns>
            <param name="input">The input string to search in the locale for.</param>
            <param name="extraArgs">Any extra formatting arguments.</param>
        </member>
        <member name="P:Pathfinder.Util.SaxProcessor.Parser">
            <summary>
            Gets the IXMLReader.
            </summary>
            <value>The reader.</value>
        </member>
        <member name="M:Pathfinder.Util.SaxProcessor.Process(System.String,System.String)">
            <summary>
            Processes the specified input.
            </summary>
            <returns>The process.</returns>
            <param name="input">Input.</param>
        </member>
        <member name="M:Pathfinder.Util.SaxProcessor.AddActionForTag(System.String,System.Action{Pathfinder.Util.SaxProcessor.ElementInfo})">
            <summary>
            Adds an action for a tag name.
            </summary>
            <param name="tag">Tag.</param>
            <param name="action">Action.</param>
        </member>
        <member name="M:Pathfinder.Util.SaxProcessor.RemoveActionForTag(System.String,System.Action{Pathfinder.Util.SaxProcessor.ElementInfo})">
            <summary>
            Removes an action for a tag name.
            </summary>
            <returns><c>true</c>, if action for tag was removed, <c>false</c> otherwise.</returns>
            <param name="tag">Tag.</param>
            <param name="action">Action.</param>
        </member>
        <member name="T:Pathfinder.Util.Types.ReadOnlyDictionary`2">
            <summary>
            Provides the base class for a generic read-only dictionary.
            </summary>
            <typeparam name="TKey">
            The type of keys in the dictionary.
            </typeparam>
            <typeparam name="TValue">
            The type of values in the dictionary.
            </typeparam>
            <remarks>
            <para>
            An instance of the <b>ReadOnlyDictionary</b> generic class is
            always read-only. A dictionary that is read-only is simply a
            dictionary with a wrapper that prevents modifying the
            dictionary; therefore, if changes are made to the underlying
            dictionary, the read-only dictionary reflects those changes. 
            See <see cref="T:System.Collections.Generic.Dictionary`2"/> for a modifiable version of 
            this class.
            </para>
            <para>
            <b>Notes to Implementers</b> This base class is provided to 
            make it easier for implementers to create a generic read-only
            custom dictionary. Implementers are encouraged to extend this
            base class instead of creating their own. 
            </para>
            </remarks>
        </member>
        <member name="M:Pathfinder.Util.Types.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the
            <see cref="T:ReadOnlyDictionary`2" /> class that wraps
            the supplied <paramref name="dictionaryToWrap"/>.
            </summary>
            <param name="dictionaryToWrap">The <see cref="T:IDictionary`2" />
            that will be wrapped.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the dictionary is null.
            </exception>
        </member>
        <member name="P:Pathfinder.Util.Types.ReadOnlyDictionary`2.Count">
            <summary>
            Gets the number of key/value pairs contained in the
            <see cref="T:ReadOnlyDictionary`2"></see>.
            </summary>
            <value>The number of key/value pairs.</value>
            <returns>The number of key/value pairs contained in the
            <see cref="T:ReadOnlyDictionary`2"></see>.</returns>
        </member>
        <member name="P:Pathfinder.Util.Types.ReadOnlyDictionary`2.Keys">
            <summary>Gets a collection containing the keys in the
            <see cref="T:ReadOnlyDictionary{TKey,TValue}"></see>.</summary>
            <value>A <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection"/> 
            containing the keys.</value>
            <returns>A
            <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection"/>
            containing the keys in the
            <see cref="T:System.Collections.Generic.Dictionary`2"></see>.
            </returns>
        </member>
        <member name="P:Pathfinder.Util.Types.ReadOnlyDictionary`2.Values">
            <summary>
            Gets a collection containing the values of the
            <see cref="T:ReadOnlyDictionary`2"/>.
            </summary>
            <value>The collection of values.</value>
        </member>
        <member name="P:Pathfinder.Util.Types.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#IsReadOnly">
            <summary>Gets a value indicating whether the dictionary is read-only.
            This value will always be true.</summary>
        </member>
        <member name="P:Pathfinder.Util.Types.ReadOnlyDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the dictionary
            is synchronized (thread safe).
            </summary>
        </member>
        <member name="P:Pathfinder.Util.Types.ReadOnlyDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to dictionary.
            </summary>
        </member>
        <member name="P:Pathfinder.Util.Types.ReadOnlyDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <returns>
            The value associated with the specified key. If the specified key
            is not found, a get operation throws a 
            <see cref="T:System.Collections.Generic.KeyNotFoundException" />,
            and a set operation creates a new element with the specified key.
            </returns>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the key is null.
            </exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            The property is retrieved and key does not exist in the collection.
            </exception>
        </member>
        <member name="M:Pathfinder.Util.Types.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Add(`0,`1)">
            <summary>This method is not supported by the 
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="key">
            The object to use as the key of the element to add.</param>
            <param name="value">
            The object to use as the value of the element to add.</param>
        </member>
        <member name="M:Pathfinder.Util.Types.ReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the <see cref="T:ReadOnlyDictionary`2" />
            contains the specified key.</summary>
            <returns>
            True if the <see cref="T:ReadOnlyDictionary`2" /> contains
            an element with the specified key; otherwise, false.
            </returns>
            <param name="key">The key to locate in the
            <see cref="T:ReadOnlyDictionary`2"></see>.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the key is null.
            </exception>
        </member>
        <member name="M:Pathfinder.Util.Types.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Remove(`0)">
            <summary>
            This method is not supported by the <see cref="T:ReadOnlyDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            True if the element is successfully removed; otherwise, false.
            </returns>
        </member>
        <member name="M:Pathfinder.Util.Types.ReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, contains the value
            associated with the specified key, if the key is found;
            otherwise, the default value for the type of the value parameter.
            This parameter is passed uninitialized.</param>
            <returns>
            <b>true</b> if the <see cref="T:ReadOnlyDictionary`2" /> contains
            an element with the specified key; otherwise, <b>false</b>.
            </returns>
        </member>
        <member name="M:Pathfinder.Util.Types.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>This method is not supported by the
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="item">
            The object to add to the <see cref="T:ICollection`1"/>.
            </param>
        </member>
        <member name="M:Pathfinder.Util.Types.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Clear">
            <summary>This method is not supported by the 
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
        </member>
        <member name="M:Pathfinder.Util.Types.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the <see cref="T:ICollection`1"/> contains a
            specific value.
            </summary>
            <param name="item">
            The object to locate in the <see cref="T:ICollection`1"/>.
            </param>
            <returns>
            <b>true</b> if item is found in the <b>ICollection</b>; 
            otherwise, <b>false</b>.
            </returns>
        </member>
        <member name="M:Pathfinder.Util.Types.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the ICollection to an Array, starting at a
            particular Array index. 
            </summary>
            <param name="array">The one-dimensional Array that is the
            destination of the elements copied from ICollection.
            The Array must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
        </member>
        <member name="M:Pathfinder.Util.Types.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>This method is not supported by the
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="item">
            The object to remove from the ICollection.
            </param>
            <returns>Will never return a value.</returns>
        </member>
        <member name="M:Pathfinder.Util.Types.ReadOnlyDictionary`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A IEnumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Pathfinder.Util.Types.ReadOnlyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An IEnumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Pathfinder.Util.Types.ReadOnlyDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>. 
            </summary>
            <param name="array">
            The one-dimensional Array that is the destination of the elements copied from 
            ICollection. The Array must have zero-based indexing.
            </param>
            <param name="index">
            The zero-based index in Array at which copying begins.
            </param>
        </member>
        <member name="P:Pathfinder.GameFilesystem.FileObject`1.Path">
            <summary>
            Gets or sets the object's full path, setting changes the object's parent
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.FileObject`1.Name">
            <summary>
            Gets or sets the object's name
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.FileObject`1.Object">
            <summary>
            Gets the vanilla object
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.FileObject`1.Parent">
            <summary>
            Gets the object's parent
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.FileObject`1.Index">
            <summary>
            Gets the index inside its parent's respective list
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.FileObject`1.Root">
            <summary>
            Gets the root Filesystem the object is within
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.FileObject`1.Type">
            <summary>
            Gets the FileType of the object.
            </summary>
            <value>The type.</value>
        </member>
        <member name="P:Pathfinder.GameFilesystem.IFileObject.Path">
            <summary>
            Gets or sets the object's full path, setting changes the object's parent
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.IFileObject.Name">
            <summary>
            Gets or sets the object's name
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.IFileObject.Object">
            <summary>
            Gets the vanilla object
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.IFileObject.Parent">
            <summary>
            Gets the object's parent
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.IFileObject.Index">
            <summary>
            Gets the index inside its parent's respective list
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.IFileObject.Root">
            <summary>
            Gets the root Filesystem the object is within
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.IFileObject.Type">
            <summary>
            Gets the FileType of the object.
            </summary>
        </member>
        <member name="F:Pathfinder.GameFilesystem.FileOpLogType.CreateFile">
            Input
            0 = file owner's ip
            1 = accessor's ip
            2 = name
            3 = data
            4 = folderPath
        </member>
        <member name="F:Pathfinder.GameFilesystem.FileOpLogType.CreateFolder">
            Input
            0 = file owner's ip
            1 = accessor's ip
            2 = name
            3 = folderPath
        </member>
        <member name="F:Pathfinder.GameFilesystem.FileOpLogType.ReadFile">
            Input
            0 = file owner's ip
            1 = accessor's ip
            2 = name
            3 = parentIndex
        </member>
        <member name="F:Pathfinder.GameFilesystem.FileOpLogType.CopyFile">
            Input
            0 = file owner's ip
            1 = accessor's ip
            2 = name
        </member>
        <member name="F:Pathfinder.GameFilesystem.FileOpLogType.DeleteFile">
            Input
            0 = file owner's ip
            1 = accessor's ip
            2 = name
            3 = folderPath
        </member>
        <member name="F:Pathfinder.GameFilesystem.FileOpLogType.DeleteFolder">
            Input
            0 = file owner's ip
            1 = accessor's ip
            2 = name
            3 = folderPath
        </member>
        <member name="F:Pathfinder.GameFilesystem.FileOpLogType.MoveFile">
            Input
            0 = file owner's ip
            1 = accessor's ip
            2 = oldName
            3 = newName
            4 = oldFolderPath
            5 = newFolderPath
        </member>
        <member name="F:Pathfinder.GameFilesystem.FileOpLogType.MoveFolder">
            Input
            0 = file owner's ip
            1 = accessor's ip
            2 = oldName
            3 = newName
            4 = oldFolderPath
            5 = newFolderPath
        </member>
        <member name="M:Pathfinder.GameFilesystem.Filesystem.SearchForDirectory(System.String,System.Boolean,System.Boolean)">
            <summary>
            Searchs for a Directory's path as far as possible.
            </summary>
            <returns>The Directory to search for, or the deepest Directory found in the path, or <c>null</c> if nullOut is true.</returns>
            <param name="path">The path to search by.</param>
            <param name="ignoreRootSymbol">If set to <c>true</c> ignores the root (/) symbol at the start.</param>
            <param name="nullOut">If set to <c>true</c> then nulls out on failure, otherwise returns furthest depth</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Filesystem.SearchForFile(System.String,System.Boolean)">
            <summary>
            Searchs for a File's path as far as possible.
            </summary>
            <returns>The File to search for, or <c>null</c> if not found.</returns>
            <param name="path">The path to search by.</param>
            <param name="ignoreRootSymbol">If set to <c>true</c> ignores the root (/) symbol at the start.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Filesystem.GetDirectoryAtDepth(System.Int32,Hacknet.OS)">
            <summary>
            Gets the Directory at the specified depth.
            </summary>
            <returns>The Directory at the inputed depth.</returns>
            <param name="depth">The depth to retrieve.</param>
            <param name="os">The OS responsible for the data relating to the Directory's depth.</param>
        </member>
        <member name="P:Pathfinder.GameFilesystem.Directory.Name">
            <summary>
            Gets or sets the directory name.
            </summary>
            <value>The name of the directory.</value>
        </member>
        <member name="P:Pathfinder.GameFilesystem.Directory.Path">
            <summary>
            Gets or sets the directory's path, both renames and modifies the directory's location.
            </summary>
            <value>The directory's path.</value>
        </member>
        <member name="P:Pathfinder.GameFilesystem.Directory.Index">
            <summary>
            Gets the index inside its parent's respective list
            </summary>
            <value>The folder index in the parent or <c>-1</c> if root directory.</value>
        </member>
        <member name="P:Pathfinder.GameFilesystem.Directory.Root">
            <summary>
            Gets the root Filesystem the Directory is within.
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.Directory.Type">
            <summary>
            Returns FileType.Directory
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.Directory.ParentDirectory">
            <summary>
            Casts the Parent FileObject to a Directory
            </summary>
            <value>The Parent as Directory</value>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.FindFile(System.String)">
            <summary>
            Finds a File within the Directory based on its name.
            </summary>
            <returns>The File or <c>null</c> if not found.</returns>
            <param name="name">The name to find.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.FindDirectory(System.String)">
            <summary>
            Finds a Directory within the Directory based on its name.
            </summary>
            <returns>The Directory or <c>null</c> if not found.</returns>
            <param name="name">The name to find.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.SearchForDirectory(System.String,System.Boolean,System.Boolean)">
            <summary>
            Searchs for a Directory's path as far as possible.
            </summary>
            <returns>The Directory to search for, or the deepest Directory found in the path, or <c>null</c> if nullOut is true.</returns>
            <param name="path">The path to search by.</param>
            <param name="ignoreRootSymbol">If set to <c>true</c> ignores the root (/) symbol at the start.</param>
            <param name="nullOut">If set to <c>true</c> then nulls out on failure, otherwise returns furthest depth</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.SearchForFile(System.String,System.Boolean)">
            <summary>
            Searchs for a File's path as far as possible.
            </summary>
            <returns>The File to search for, or <c>null</c> if not found.</returns>
            <param name="path">The path to search by.</param>
            <param name="ignoreRootSymbol">If set to <c>true</c> ignores the root (/) symbol at the start.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.GetFile(System.Int32)">
            <summary>
            Gets a File based on its Index.
            </summary>
            <remarks>This method is the most bare and unsafe method of File retrieval</remarks>
            <returns>The File who contains said Index.</returns>
            <param name="index">The Index to find.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.GetDirectory(System.Int32)">
            <summary>
            Gets a Directory based on its Index.
            </summary>
            <remarks>This method is the most bare and unsafe method of Directory retrieval</remarks>
            <returns>The Directory who contains said Index.</returns>
            <param name="index">The Index to find.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.CreateFile(System.String,System.String)">
            <summary>
            Creates a new File based on the name and data.
            </summary>
            <returns>The File that was created.</returns>
            <param name="name">The name to assign to the File.</param>
            <param name="data">The data to assign to the File.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.CreateFile(System.String,Pathfinder.Executable.Interface)">
            <summary>
            Creates a File based on the name and the Executable.IInterface generated file data.
            </summary>
            <returns>The File that was created.</returns>
            <param name="name">The name to assign to the File.</param>
            <param name="exeInterface">The Executable.IInterface whose file data is to be generated.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.CreateExecutableFile(System.String,System.String)">
            <summary>
            Creates an executable File based on the name and the file data string id.
            </summary>
            <returns>The executable File that was created.</returns>
            <param name="name">The name to assign to the File.</param>
            <param name="exeId">The file data string id.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.CreateExecutableFile(System.String,System.Int32)">
            <summary>
            Creates a vanilla executable File based on the name and the vanilla data index.
            </summary>
            <returns>The executable File that was created.</returns>
            <param name="name">The name to assign to the File.</param>
            <param name="vanillaIndex">The vanilla data index.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.CreateRandomFile(System.String,System.String)">
            <summary>
            Creates a random File based either on the name or data. (if neither are null then same as CreateFile)
            </summary>
            <returns>The random File that was created.</returns>
            <param name="name">The name to assign to the File or <c>null</c> to apply a random name.</param>
            <param name="data">The data to assign to the File or <c>null</c> to apply random data.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.CreateRandomFile(System.UInt32,System.Nullable{System.UInt32})">
            <summary>
            Creates a random File based on the nameIndex and dataIndex.
            </summary>
            <returns>The random File that was created.</returns>
            <param name="nameIndex">The FileEntry filenames index. (which will max out at the largest index)</param>
            <param name="dataIndex">The FileEntry fileData index, or nameIndex if <c>null</c>.
            (which will max out at the largest index)</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.CreateDirectory(System.String)">
            <summary>
            Creates a new Directory based on the name.
            </summary>
            <returns>The Directory that was created.</returns>
            <param name="name">The name to assign to the Directory.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.RemoveFile(System.String)">
            <summary>
            Removes a File in the Directory by its name.
            </summary>
            <returns><c>true</c>, if File was found and removed, <c>false</c> otherwise.</returns>
            <param name="name">The name to find.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.RemoveFile(Pathfinder.GameFilesystem.File)">
            <summary>
            Removes a File in the Directory.
            </summary>
            <returns><c>true</c>, if File was found and removed, <c>false</c> otherwise.</returns>
            <param name="f">The File to find.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.RemoveDirectory(System.String)">
            <summary>
            Removes a Directory in the Directory by its name.
            </summary>
            <returns><c>true</c>, if Directory was found and removed, <c>false</c> otherwise.</returns>
            <param name="name">The name to find.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.RemoveDirectory(Pathfinder.GameFilesystem.Directory)">
            <summary>
            Removes a Directory in the Directory.
            </summary>
            <returns><c>true</c>, if Directory was found and removed, <c>false</c> otherwise.</returns>
            <param name="d">The Directory to find.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.MoveFile(Pathfinder.GameFilesystem.File,Pathfinder.GameFilesystem.Directory)">
            <summary>
            Moves a File to a new Directory.
            </summary>
            <returns>The moved File.</returns>
            <param name="f">The File to move.</param>
            <param name="newDir">The new Directory.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.MoveDirectory(Pathfinder.GameFilesystem.Directory,Pathfinder.GameFilesystem.Directory)">
            <summary>
            Moves a Directory to a new Directory.
            </summary>
            <returns>The moved Directory.</returns>
            <param name="d">The Directory to move.</param>
            <param name="newDir">The new Directory.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.MoveTo(Pathfinder.GameFilesystem.Directory)">
            <summary>
            Moves the Directory to a new Directory.
            </summary>
            <returns>The Directory to move to.</returns>
            <param name="to">The moved Directory.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.Contains(Pathfinder.GameFilesystem.File)">
            <summary>
            Determines whether the specified File is contained within the Directory.
            </summary>
            <returns><c>true</c>, if the File isn't null and contained within the Directory, <c>false</c> otherwise.</returns>
            <param name="f">The File to determine is contained within.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.Contains(Pathfinder.GameFilesystem.Directory)">
            <summary>
            Determines whether the specified Directory is contained within the Directory.
            </summary>
            <returns><c>true</c>, if the Directory isn't null and contained within the Directory, <c>false</c> otherwise.</returns>
            <param name="d">The Directory to determine is contained within.</param>
        </member>
        <member name="M:Pathfinder.GameFilesystem.Directory.ContainsFile(System.String,System.String)">
            <summary>
            Determines whether a File with the specified name and/or data is contained within the Directory
            </summary>
            <returns><c>true</c>, if File is contained in the Directory, <c>false</c> otherwise.</returns>
            <param name="name">The name to search for or <c>null</c>.</param>
            <param name="data">The data to search for or <c>null</c>.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Pathfinder.GameFilesystem.Directory.ContainsDirectory(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})" -->
        <member name="P:Pathfinder.GameFilesystem.Directory.Item(System.String)">
            <summary>
            Gets the first <see cref="T:Pathfinder.GameFilesystem.IFileObject"/> that contains the specified name,
            searching through files first.
            </summary>
            <param name="name">Name.</param>
        </member>
        <member name="P:Pathfinder.GameFilesystem.Directory.Files">
            <summary>
            Retrieves a list of Files contained within the Directory.
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.Directory.Directories">
            <summary>
            Retrieves a list of Directories contained within the Directory.
            </summary>
            <value>The directories.</value>
        </member>
        <member name="P:Pathfinder.GameFilesystem.Directory.FileCount">
            <summary>
            Retrieves the amount of Files within the Directory.
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.Directory.DirectoryCount">
            <summary>
            Retrieves the amount of Directories within the Directory.
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.File.Name">
            <summary>
            Gets or sets the File's name. (logs as move if change is attempted)
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.File.Index">
            <summary>
            Gets the index inside its parent's respective list
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.File.Root">
            <summary>
            Gets the root Filesystem the File is within.
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.File.Type">
            <summary>
            Returns FileType.File
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.File.Path">
            <summary>
            Gets or sets the File's full path, setting changes the File's parent.
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.File.Data">
            <summary>
            Gets or sets the File's data.
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.File.Size">
            <summary>
            Gets or sets the File's size.
            </summary>
        </member>
        <member name="M:Pathfinder.GameFilesystem.File.UpdateFileSize">
            <summary>
            Updates the size of the File according to the standard set in Hacknet.
            </summary>
        </member>
        <member name="P:Pathfinder.GameFilesystem.File.Head">
            <summary>
            Retrieves the head of the file, or the first 50 characters of the File's data before a newline.
            </summary>
        </member>
        <member name="M:Pathfinder.GameFilesystem.File.MoveTo(Pathfinder.GameFilesystem.Directory)">
            <summary>
            Moves the File to a different Directory.
            </summary>
            <returns>The File after its been moved.</returns>
            <param name="to">The Directory to move the File to.</param>
        </member>
        <member name="P:Pathfinder.Extension.Info.Id">
            <summary>
            Gets the extension identifier.
            </summary>
            <value>The identifier.</value>
        </member>
        <member name="P:Pathfinder.Extension.Info.IsActive">
            <summary>
            Gets a value indicating whether this <see cref="T:Pathfinder.Extension.Info"/> is active.
            </summary>
            <value><c>true</c> if is active; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Pathfinder.Extension.Info.Name">
            <summary>
            Gets the extension's name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:Pathfinder.Extension.Info.Description">
            <summary>
            Gets the extension's description.
            </summary>
            <value>The description.</value>
        </member>
        <member name="P:Pathfinder.Extension.Info.LogoPath">
            <summary>
            Gets the extension's logo path. (if it does not exist or is null, chooses the default logo)
            </summary>
            <value>The logo path.</value>
        </member>
        <member name="P:Pathfinder.Extension.Info.AllowSaves">
            <summary>
            Gets a value indicating whether this <see cref="T:Pathfinder.Extension.Info"/> allows saves.
            </summary>
            <value><c>true</c> if allows saves; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Pathfinder.Extension.Info.OnConstruct(Hacknet.OS)">
            <summary>
            Executes on extension construction.
            </summary>
            <param name="os">The Os.</param>
        </member>
        <member name="M:Pathfinder.Extension.Info.OnLoad(Hacknet.OS,System.IO.Stream)">
            <summary>
            Executes on extension loading.
            </summary>
            <param name="os">The Os.</param>
            <param name="loadingStream">The Loading stream.</param>
        </member>
        <member name="T:Pathfinder.Internal.InternalUtility.MethodInvoker">
            <summary>
            Hardcoded Validatation behavior dependent on parameters
            </summary>
            <returns><paramref name="input"/> with validation changes if <paramref name="overrideIdBeh"/> is false</returns>
            <param name="input">Input string, commonly identifier, for validation.</param>
            <param name="additNoun">Additional noun that is being added.</param>
            <param name="instanceName">Instance Name of the additional noun.</param>
            <param name="periodThrow">If set to <c>true</c> will throw if a period is found in id and <paramref name="overrideIdBeh"/> is false.</param>
            <param name="excludeExt">If set to <c>true</c> will exclude extension references in id.</param>
            <param name="overrideIdBeh">If set to <c>true</c> overrides all identifier manipulation behavior.</param>
            <param name="ignoreAddLog">If set to <c>true</c> overrides logger behavior.</param>
            <param name="frames">Stack Frame backward steps to check for validation and user method.</param>
        </member>
        <member name="P:Pathfinder.ModManager.IMod.Identifier">
            <summary>
            Retrieves the Mod's identifier.
            </summary>
            <value>The Mod's identifier</value>
        </member>
        <member name="P:Pathfinder.ModManager.Mod.Identifier">
            <summary>
            Retrieves the Mod's identifier.
            </summary>
            <value>The Mod's identifier</value>
        </member>
        <member name="M:Pathfinder.ModManager.Mod.Load">
            <summary>
            Called when the mod is being loaded, use to ensure all mod related stuff is ready to be loaded
            </summary>
            <remarks>DO NOT USE TO LOAD CONTENT</remarks>
        </member>
        <member name="M:Pathfinder.ModManager.Mod.LoadContent">
            <summary>
            Loads the mod's content.
            </summary>
        </member>
        <member name="M:Pathfinder.ModManager.Mod.Unload">
            <summary>
            Called when the mod is being unloaded
            </summary>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.AddModdedDaemon(Hacknet.Computer,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Adds a modded Daemon via the interface id string to the Computer.
            </summary>
            <returns>The modded Daemon instance.</returns>
            <param name="comp">The Computer</param>
            <param name="interfaceId">Interface Identifier.</param>
            <param name="input">The input for the LoadInstance interface function.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.AddDaemon``1(Hacknet.Computer,System.Object[])">
            <summary>
            Adds a Daemon via generics to the Computer.
            </summary>
            <returns>The created Daemon.</returns>
            <param name="comp">The Computer</param>
            <param name="input">The input for the constructor.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetDaemonList(Hacknet.Computer,System.Type)">
            <summary>
            Retrieves a List of daemons exactly of Daemon from the Computer
            </summary>
            /// <param name="daemonType">The exact Type to search for</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetDaemonList``1(Hacknet.Computer)">
            <summary>
            Retrieves a List of Daemons whose Type is or is derived from T, pulled from Computer
            </summary>
            <typeparam name="T">The Type or derivative of the type to search for in the Daemon List</typeparam>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetModdedDaemon(Hacknet.Computer,System.Type)">
            <summary>
            Retrieves the first Daemon.Instance whose interface Type is exactly modInterface.
            </summary>
            <param name="modInterface">The exact Type to find</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetModdedDaemon``1(Hacknet.Computer)">
            <summary>
            Retrieves the first mod Daemon.Instance whose interface Type is or is derived from T.
            </summary>
            <typeparam name="T">The Type or derivative of the type to search for in the Daemon List</typeparam>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetModdedDaemonList(Hacknet.Computer,System.Type)">
            <summary>
            Retrieves a List of Daemon.Instance whose interface Type is exactly modInterface.
            </summary>
            /// <param name="modInterface">The exact Type to find</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetModdedDaemonList``1(Hacknet.Computer)">
            <summary>
            Retrieves a List of mod Daemon.Instance whose interface Type is or is derived from T
            </summary>
            <typeparam name="T">The Type or derivative of the type to search for in the Daemon List</typeparam>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.AddLink(Hacknet.Computer,Hacknet.Computer)">
            <summary>
            Adds a link on the NetworkMap from Computer connecting to newLink.
            </summary>
            <returns><c>true</c>, if the link was added, <c>false</c> otherwise.</returns>
            <param name="comp">The Computer</param>
            <param name="newLink">The New link.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetOS(Hacknet.Computer)">
            <summary>
            Retireves the OS of Computer.
            </summary>
            <returns>The OS.</returns>
            <param name="comp">The Computer</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetNetworkMap(Hacknet.Computer)">
            <summary>
            Retrieves the NetworkMap of Computer.
            </summary>
            <returns>The NetworkMap.</returns>
            <param name="comp">The Computer</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.AddVanillaPort(Hacknet.Computer,Pathfinder.Util.ExeInfoManager.ExecutableInfo,System.Boolean)">
            <summary>
            Adds a vanilla port by ExecutableInfo.
            </summary>
            <returns><c>true</c>, if vanilla port was added, <c>false</c> otherwise.</returns>
            <param name="comp">The Computer</param>
            <param name="info">The ExecutableInfo for the port</param>
            <param name="unlocked">If set to <c>true</c> then sets the port to be unlocked.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.AddVanillaPort(Hacknet.Computer,System.String,System.Boolean)">
            <summary>
            Adds a vanilla port by port name.
            </summary>
            <returns><c>true</c>, if vanilla port was added, <c>false</c> otherwise.</returns>
            <param name="comp">The Computer</param>
            <param name="portName">The name for the port</param>
            <param name="unlocked">If set to <c>true</c> then sets the port to be unlocked.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.AddVanillaPort(Hacknet.Computer,System.Int32,System.Boolean)">
            <summary>
            Adds a vanilla port by port number.
            </summary>
            <returns><c>true</c>, if vanilla port was added, <c>false</c> otherwise.</returns>
            <param name="comp">The Computer</param>
            <param name="portNum">The number for the port</param>
            <param name="unlocked">If set to <c>true</c> then sets the port to be unlocked.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.AddModPort(Hacknet.Computer,Pathfinder.Port.Type,System.Boolean,System.Boolean)">
            <summary>
            Adds the mod port by port type.
            </summary>
            <returns><c>true</c>, if mod port was added, <c>false</c> otherwise.</returns>
            <param name="comp">The Computer</param>
            <param name="port">The Port.Type to add to Computer</param>
            <param name="unlocked">If set to <c>true</c> then sets the port to be unlocked.</param>
            <param name="replace">If set to true then may replace any port whose display port is equal to the new type</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Pathfinder.Game.Computer.Extensions.AddModPort(Hacknet.Computer,System.String,System.Boolean,System.Boolean)" -->
        <member name="M:Pathfinder.Game.Computer.Extensions.RemoveVanillaPort(Hacknet.Computer,Pathfinder.Util.ExeInfoManager.ExecutableInfo)">
            <summary>
            Removes a vanilla port by ExecutableInfo.
            </summary>
            <returns><c>true</c>, if vanilla port was found and removed, <c>false</c> otherwise.</returns>
            <param name="comp">The Computer</param>
            <param name="info">The ExecutableInfo for the port</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.RemoveVanillaPort(Hacknet.Computer,System.String)">
            <summary>
            Removes a vanilla port by port name.
            </summary>
            <returns><c>true</c>, if vanilla port was found and removed, <c>false</c> otherwise.</returns>
            <param name="comp">The Computer</param>
            <param name="portName">The name for the port</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.RemoveVanillaPort(Hacknet.Computer,System.Int32)">
            <summary>
            Removes a vanilla port by port number.
            </summary>
            <returns><c>true</c>, if vanilla port was found and removed, <c>false</c> otherwise.</returns>
            <param name="comp">The Computer</param>
            <param name="portNum">The number for the port</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetModdedPortList(Hacknet.Computer)">
            <summary>
            Gets a read-only list of modded ports.
            </summary>
            <returns>The list of modded ports.</returns>
            <param name="comp">The Computer</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.HasVanilaPort(Hacknet.Computer,Pathfinder.Util.ExeInfoManager.ExecutableInfo)">
            <summary>
            Determines whether Computer has a certain vanilla port. (ignoring remap)
            </summary>
            <returns><c>true</c>, if Computer has the port, <c>false</c> otherwise.</returns>
            <param name="info">The ExecutableInfo to search by.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.HasVanillaPort(Hacknet.Computer,System.String)">
            <summary>
            Determines whether Computer has a certain vanilla port. (ignoring remap)
            </summary>
            <returns><c>true</c>, if Computer has the port, <c>false</c> otherwise.</returns>
            <param name="portName">The port name to search by.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.HasVanillaPort(Hacknet.Computer,System.Int32)">
            <summary>
            Determines whether Computer has a certain vanilla port. (ignoring remap)
            </summary>
            <returns><c>true</c>, if Computer has the port, <c>false</c> otherwise.</returns>
            <param name="portNum">The port number to search by.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.HasModPort(Hacknet.Computer,Pathfinder.Port.Type)">
            <summary>
            Determines whether Computer has a certain mod port.
            </summary>
            <returns><c>true</c>, if Computer has the port, <c>false</c> otherwise.</returns>
            <param name="port">The Port.Type to search by.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.HasModPort(Hacknet.Computer,System.String)">
            <summary>
            Determines whether Computer has a certain mod port.
            </summary>
            <returns><c>true</c>, if Computer has the port, <c>false</c> otherwise.</returns>
            <param name="id">The modded port's registry id to search by.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.IsVanillaPortOpen(Hacknet.Computer,Pathfinder.Util.ExeInfoManager.ExecutableInfo)">
            <summary>
            Determines whether the vanilla port is open. (ignoring remap)
            </summary>
            <returns><c>true</c>, if the port exists and is open, <c>false</c> otherwise.</returns>
            <param name="comp">The Computer</param>
            <param name="info">The ExecutableInfo to search by</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.IsVanillaPortOpen(Hacknet.Computer,System.String)">
            <summary>
            Determines whether the vanilla port is open. (ignoring remap)
            </summary>
            <returns><c>true</c>, if the port exists and is open, <c>false</c> otherwise.</returns>
            <param name="comp">The Computer</param>
            <param name="portName">The port name to search by</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.IsVanillaPortOpen(Hacknet.Computer,System.Int32)">
            <summary>
            Determines whether the vanilla port is open. (ignoring remap)
            </summary>
            <returns><c>true</c>, if the port exists and is open, <c>false</c> otherwise.</returns>
            <param name="comp">The Computer</param>
            <param name="portNum">The port number to search by</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.IsModPortOpen(Hacknet.Computer,Pathfinder.Port.Type)">
            <summary>
            Determines whether the modded port is open. (ignoring remap)
            </summary>
            <returns><c>true</c>, if the port exists and is open, <c>false</c> otherwise.</returns>
            <param name="comp">The Computer</param>
            <param name="port">The Port.Type to find</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.IsModPortOpen(Hacknet.Computer,System.String)">
            <summary>
            Determines whether the mod port is open. (ignoring remap)
            </summary>
            <returns><c>true</c>, if the port exists and is open, <c>false</c> otherwise.</returns>
            <param name="comp">The Computer</param>
            <param name="id">The modded port's registry id to search by</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.OpenVanillaPort(Hacknet.Computer,Pathfinder.Util.ExeInfoManager.ExecutableInfo,System.String)">
            <summary>
            Opens a vanilla port. Doesn't add a port
            </summary>
            <param name="comp">The Computer.</param>
            <param name="info">The ExecutableInfo to search for.</param>
            <param name="ipFrom">The ip responsible for the change.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.OpenVanillaPort(Hacknet.Computer,System.String,System.String)">
            <summary>
            Opens a vanilla port. Doesn't add a port
            </summary>
            <param name="comp">The Computer.</param>
            <param name="portName">The port name to search for.</param>
            <param name="ipFrom">The ip responsible for the change.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.OpenVanillaPort(Hacknet.Computer,System.Int32,System.String)">
            <summary>
            Opens a vanilla port. Doesn't add a port
            </summary>
            <param name="comp">The Computer.</param>
            <param name="portNum">The port number to search for.</param>
            <param name="ipFrom">The ip responsible for the change.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.OpenModPort(Hacknet.Computer,Pathfinder.Port.Type,System.String)">
            <summary>
            Opens a mod port. Doesn't add a port
            </summary>
            <param name="comp">The Computer.</param>
            <param name="port">The Port.Type to search for.</param>
            <param name="ipFrom">The ip responsible for the change.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.OpenModPort(Hacknet.Computer,System.String,System.String)">
            <summary>
            Opens a mod port. Doesn't add a port
            </summary>
            <param name="comp">The Computer.</param>
            <param name="id">The Type id to search for.</param>
            <param name="ipFrom">The ip responsible for the change.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.CloseVanillaPort(Hacknet.Computer,Pathfinder.Util.ExeInfoManager.ExecutableInfo,System.String)">
            <summary>
            Closes a vanilla port. Doesn't add a port
            </summary>
            <param name="comp">The Computer.</param>
            <param name="info">The ExecutableInfo to search for.</param>
            <param name="ipFrom">The ip responsible for the change.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.CloseVanillaPort(Hacknet.Computer,System.String,System.String)">
            <summary>
            Closes a vanilla port. Doesn't add a port
            </summary>
            <param name="comp">The Computer.</param>
            <param name="portName">The port name to search for.</param>
            <param name="ipFrom">The ip responsible for the change.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.CloseVanillaPort(Hacknet.Computer,System.Int32,System.String)">
            <summary>
            Closes a vanilla port. Doesn't add a port
            </summary>
            <param name="comp">The Computer.</param>
            <param name="portNum">The port number to search for.</param>
            <param name="ipFrom">The ip responsible for the change.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.CloseModPort(Hacknet.Computer,Pathfinder.Port.Type,System.String)">
            <summary>
            Closes a mod port. Doesn't add a port
            </summary>
            <param name="comp">The Computer.</param>
            <param name="port">The Port.Type to search for.</param>
            <param name="ipFrom">The ip responsible for the change.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.CloseModPort(Hacknet.Computer,System.String,System.String)">
            <summary>
            Closes a mod port. Doesn't add a port
            </summary>
            <param name="comp">The Computer.</param>
            <param name="id">The Type id to search for.</param>
            <param name="ipFrom">The ip responsible for the change.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.AddEOSDevice(Hacknet.Computer,Hacknet.Computer)">
            <summary>
            Adds a EOS Device connection represented by device
            </summary>
            <param name="comp">The Computer.</param>
            <param name="device">The Computer device to link to.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.CreateEOSDeviceOn(Hacknet.Computer,System.String,System.String,System.String,System.Nullable{Microsoft.Xna.Framework.Vector2},System.String,System.Collections.Generic.List{System.Int32},System.Int32,Hacknet.Folder,System.Collections.Generic.List{Pathfinder.Port.Type})">
            <summary>
            Creates the EOS Device connected to Computer.
            </summary>
            <returns>The created EOS Device.</returns>
            <param name="comp">The Computer.</param>
            <param name="name">The device's name.</param>
            <param name="ip">The device's ip.</param>
            <param name="icon">The device's icon.</param>
            <param name="location">The device's NetworkMap position.</param>
            <param name="password">The device's password, by game default should be alpine.</param>
            <param name="vanillaPorts">The device's closed vanilla port numbers.</param>
            <param name="portCracksRequired">The device's cracked ports required to unlock.</param>
            <param name="eosFolder">The device's eos folder.</param>
            <param name="modPorts">The device's closed modded Port.Type List.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetEOSDevicesBy(Hacknet.Computer,Pathfinder.Util.RetrieveType)">
            <summary>
            Gets the EOS Devices sorted by retType.
            </summary>
            <returns>The EOS Devices.</returns>
            <param name="comp">The Computer.</param>
            <param name="retType">Determines how to sort the devices.</param>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetEOSDevicesById(Hacknet.Computer)">
            <summary>
            Sorts EOS Devices by ids
            </summary>
            <see cref="M:Pathfinder.Game.Computer.Extensions.GetEOSDevicesBy(Hacknet.Computer,Pathfinder.Util.RetrieveType)"/>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetEOSDevicesByIp(Hacknet.Computer)">
            <summary>
            Sorts EOS Devices by ips
            </summary>
            <see cref="M:Pathfinder.Game.Computer.Extensions.GetEOSDevicesBy(Hacknet.Computer,Pathfinder.Util.RetrieveType)"/>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetEOSDevicesByName(Hacknet.Computer)">
            <summary>
            Sorts EOS Devices by names
            </summary>
            <see cref="M:Pathfinder.Game.Computer.Extensions.GetEOSDevicesBy(Hacknet.Computer,Pathfinder.Util.RetrieveType)"/>
        </member>
        <member name="M:Pathfinder.Game.Computer.Extensions.GetEOSDevicesByIndex(Hacknet.Computer)">
            <summary>
            Sorts EOS Devices by NetworkMap indexes
            </summary>
            <see cref="M:Pathfinder.Game.Computer.Extensions.GetEOSDevicesBy(Hacknet.Computer,Pathfinder.Util.RetrieveType)"/>
        </member>
        <member name="M:Pathfinder.Game.NetworkMap.Extensions.DiscoverNode(Hacknet.NetworkMap,Hacknet.Computer,System.Single)">
            <summary>
            Discovers a Computer node if it exists.
            </summary>
            <returns><c>true</c>, if node exists and was discovered, <c>false</c> otherwise.</returns>
            <param name="netmap">The NetworkMap</param>
            <param name="comp">The Computer node to discover</param>
            <param name="flashTime">The flash time length for the discovery</param>
        </member>
        <member name="M:Pathfinder.Game.NetworkMap.Extensions.DiscoverNodeByName(Hacknet.NetworkMap,System.String,System.Single)">
            <summary>
            Discovers a Computer node by name if it exists.
            </summary>
            <returns><c>true</c>, if node exists and was discovered, <c>false</c> otherwise.</returns>
            <param name="netmap">The NetworkMap</param>
            <param name="name">The Computer name to discover</param>
            <param name="flashTime">The flash time length for the discovery</param>
        </member>
        <member name="M:Pathfinder.Game.NetworkMap.Extensions.DiscoverNodeByIp(Hacknet.NetworkMap,System.String,System.Single)">
            <summary>
            Discovers a Computer node by ip if it exists.
            </summary>
            <returns><c>true</c>, if node exists and was discovered, <c>false</c> otherwise.</returns>
            <param name="netmap">The NetworkMap</param>
            <param name="ip">The Computer ip to discover</param>
            <param name="flashTime">The flash time length for the discovery</param>
        </member>
        <member name="M:Pathfinder.Game.NetworkMap.Extensions.DiscoverNodes(Hacknet.NetworkMap,System.Collections.Generic.IEnumerable{Hacknet.Computer},System.Single)">
            <summary>
            Discovers nodes by a Computer enumerable.
            </summary>
            <returns>A List of booleans for each discovered node</returns>
            <param name="netmap">The NetworkMap</param>
            <param name="comps">The Computer nodes to discover</param>
            <param name="flashTime">The flash time length for the discovery</param>
            <seealso cref="M:Pathfinder.Game.NetworkMap.Extensions.DiscoverNode(Hacknet.NetworkMap,Hacknet.Computer,System.Single)"/>
        </member>
        <member name="M:Pathfinder.Game.NetworkMap.Extensions.DiscoverNodesByNames(Hacknet.NetworkMap,System.Collections.Generic.IEnumerable{System.String},System.Single)">
            <summary>
            Discovers Computer nodes by a name enumerable.
            </summary>
            <returns>A List of booleans for each discovered node</returns>
            <param name="netmap">The NetworkMap</param>
            <param name="names">The Computer names to discover</param>
            <param name="flashTime">The flash time length for the discovery</param>
            <seealso cref="M:Pathfinder.Game.NetworkMap.Extensions.DiscoverNodeByName(Hacknet.NetworkMap,System.String,System.Single)"/>
        </member>
        <member name="M:Pathfinder.Game.NetworkMap.Extensions.DiscoverNodesByIps(Hacknet.NetworkMap,System.Collections.Generic.IEnumerable{System.String},System.Single)">
            <summary>
            Discovers Computer nodes by an ip enumerable.
            </summary>
            <returns>A List of booleans for each discovered node</returns>
            <param name="netmap">The NetworkMap</param>
            <param name="ips">The Computer ips to discover</param>
            <param name="flashTime">The flash time length for the discovery</param>
            <seealso cref="M:Pathfinder.Game.NetworkMap.Extensions.DiscoverNodeByIp(Hacknet.NetworkMap,System.String,System.Single)"/>
        </member>
        <member name="M:Pathfinder.Game.NetworkMap.Extensions.GetComputer(Hacknet.NetworkMap,System.Int32)">
            <summary>
            Retrieves a Computer by index.
            </summary>
            <returns>The Computer or <c>null</c> if not found.</returns>
            <param name="netmap">The NetworkMap</param>
            <param name="index">The index to get.</param>
        </member>
        <member name="M:Pathfinder.Game.NetworkMap.Extensions.GetComputerByName(Hacknet.NetworkMap,System.String)">
            <summary>
            Retrieves a Computer by name.
            </summary>
            <returns>The Computer or <c>null</c> if not found.</returns>
            <param name="netmap">The NetworkMap</param>
            <param name="name">The name to get.</param>
        </member>
        <member name="M:Pathfinder.Game.NetworkMap.Extensions.GetComputerByIp(Hacknet.NetworkMap,System.String)">
            <summary>
            Retrieves a Computer by ip.
            </summary>
            <returns>The Computer or <c>null</c> if not found.</returns>
            <param name="netmap">The NetworkMap</param>
            <param name="ip">The ip to get.</param>
        </member>
        <member name="M:Pathfinder.Game.NetworkMap.Extensions.GetComputerById(Hacknet.NetworkMap,System.String)">
            <summary>
            Retrieves a Computer by identifier.
            </summary>
            <returns>The Computer or <c>null</c> if not found.</returns>
            <param name="netmap">The NetworkMap.</param>
            <param name="id">The id to get.</param>
        </member>
        <member name="M:Pathfinder.Game.NetworkMap.Extensions.AddLink(Hacknet.NetworkMap,Hacknet.Computer,Hacknet.Computer)">
            <summary>
            Adds a link to linkStart connecting to linkEnd.
            </summary>
            <returns><c>true</c>, if the link was added, <c>false</c> otherwise.</returns>
            <param name="netmap">The NetworkMap</param>
            <param name="linkStart">The link start.</param>
            <param name="linkEnd">The link end.</param>
        </member>
        <member name="M:Pathfinder.Game.OS.Extensions.GetExesFor(Hacknet.OS,System.Type)">
            <summary>
            Retrieves the List of ExeModule whose Type is exactly instanceType 
            </summary>
            <param name="instanceType">The exact Type to search for in the Executable List</param>
        </member>
        <member name="M:Pathfinder.Game.OS.Extensions.GetExesFor``1(Hacknet.OS)">
            <summary>
            Retrieves the List of ExeModule List whose Type is or is derived from T 
            </summary>
            <typeparam name="T">The Type or derivative of the type to search for in the Executable List</typeparam>
        </member>
        <member name="M:Pathfinder.Game.OS.Extensions.GetModExeInterfaceFor(Hacknet.OS,System.Type)">
            <summary>
            Retrieves the List of Executable.Instance whose Type is exactly instanceType 
            </summary>
            <param name="interfaceType">The exact Type to search for in the Executable List</param>
        </member>
        <member name="M:Pathfinder.Game.OS.Extensions.GetModExeInterfaceFor``1(Hacknet.OS)">
            <summary>
            Retrieves the List of Executable.Instance List whose Type is or is derived from T 
            </summary>
            <typeparam name="T">The Type or derivative of the type to search for in the Executable List</typeparam>
        </member>
        <member name="M:Pathfinder.Game.OS.Extensions.KillExecutableModule(Hacknet.OS,Hacknet.ExeModule,System.Boolean)">
            <summary>
            Kills the ExeModules on the OS.
            </summary>
            <returns><c>true</c>, if ExeModule was killed, <c>false</c> otherwise.</returns>
            <param name="os">The OS.</param>
            <param name="module">The ExeModule to kill.</param>
            <param name="shouldWrite">If set to <c>true</c> then success will be written to the OS.</param>
        </member>
        <member name="M:Pathfinder.Game.OS.Extensions.KillExecutableModule(Hacknet.OS,System.String,System.Boolean,System.Boolean)">
            <summary>
            Kills the first ExeModules on the OS that matches the string.
            </summary>
            <returns><c>true</c>, if ExeModule was killed, <c>false</c> otherwise.</returns>
            <param name="os">The OS.</param>
            <param name="input">The input string (or string representation of the integer PID) to search against.</param>
            <param name="searchName">If set to <c>true</c> then can search by IdentifierName.</param>
            <param name="shouldWrite">If set to <c>true</c> will write success and failure to the OS.</param>
        </member>
        <member name="M:Pathfinder.Game.OS.Extensions.KillAllExecutableModules(Hacknet.OS,System.Boolean)">
            <summary>
            Kills all ExeModules.
            </summary>
            <param name="os">The OS.</param>
            <param name="shouldWrite">If set to <c>true</c> will write success to the OS.</param>
        </member>
        <member name="M:Pathfinder.Game.OS.Extensions.GetCurrentComputer(Hacknet.OS)">
            <summary>
            Retrieves the active network Computer according to the OS
            </summary>
        </member>
        <member name="M:Pathfinder.Game.OS.Extensions.Write(Hacknet.OS,System.String,System.Object[])">
            <summary>
            Writes the formatted string to OS terminal.
            </summary>
            <param name="os">The OS.</param>
            <param name="write">The formatted string to write.</param>
        </member>
        <member name="M:Pathfinder.Game.OS.Extensions.WriteSingle(Hacknet.OS,System.String,System.Object[])">
            <summary>
            Writes the formatted string directly to OS terminal. Less safe then <see cref="M:Pathfinder.Game.OS.Extensions.Write(Hacknet.OS,System.String,System.Object[])"/>
            </summary>
            <param name="os">The OS.</param>
            <param name="write">The formatted string to write.</param>
        </member>
        <member name="M:Pathfinder.Game.ExeModule.Extensions.Kill(Hacknet.ExeModule,System.Boolean)">
            <summary>
            Kill the ExeModule.
            </summary>
            <returns><c>true</c>, if ExeModule was found, killed, and removed, <c>false</c> otherwise.</returns>
            <param name="module">The ExeModule to kill.</param>
            <param name="shouldWrite">If set to <c>true</c> then success will be written to the OS.</param>
        </member>
        <member name="M:Pathfinder.Serializable.Handler.RegisterAction(System.String,Pathfinder.Serializable.Action.Interface)">
            <summary>
            Adds a serializable action to Hacknet
            </summary>
            <returns><c>true</c> if added to the game, <c>false</c> otherwise</returns>
            <param name="condition">The serializable action used in the XML.</param>
            <param name="deserializer">The function run when deserializing the action.</param>
        </member>
        <member name="M:Pathfinder.Serializable.Handler.RegisterCondition(System.String,Pathfinder.Serializable.Condition.Interface)">
            <summary>
            Adds a serializable action to Hacknet
            </summary>
            <returns><c>true</c> if added to the game, <c>false</c> otherwise</returns>
            <param name="condition">The serializable action used in the XML.</param>
            <param name="deserializer">The function run when deserializing the action.</param>
        </member>
        <member name="T:Sax.Net.IAttributes">
            <summary>
              Interface for a list of XML attributes.
              <para></para>
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <see cref='!:http:///www.saxproject.org'>http:///www.saxproject.org</see>
                for further information.
              </blockquote>
              <para></para>
              <para>
                This interface allows access to a list of attributes in
                three different ways:
              </para>
              <para></para>
              <ol>
                <li>by attribute index;</li>
                <li>by Namespace-qualified name; or</li>
                <li>by qualified (prefixed) name.</li>
              </ol>
              <para></para>
              <para>
                The list will not contain attributes that were declared
                #IMPLIED but not specified in the start tag.  It will also not
                contain attributes used as Namespace declarations (xmlns///) unless
                the <c>http:///xml.org/sax/features/namespace-prefixes</c>
                feature is set to <c>true</c> (it is <c>false</c> by
                default).
                Because SAX2 conforms to the original "Namespaces in XML"
                recommendation, it normally does not
                give namespace declaration attributes a namespace URI.
              </para>
              <para></para>
              <para>
                Some SAX2 parsers may support using an optional feature flag
                (<c>http:///xml.org/sax/features/xmlns-uris</c>) to request
                that those attributes be given URIs, conforming to a later
                backwards-incompatible revision of that recommendation.  (The
                attribute's "local name" will be the prefix, or "xmlns" when
                defining a default element namespace.)  For portability, handler
                code should always resolve that conflict, rather than requiring
                parsers that can change the setting of that feature flag.
              </para>
              <para></para>
              <para>
                If the namespace-prefixes feature (see above) is
                <c>false</c>, access by qualified name may not be available; if
                the <c>http:///xml.org/sax/features/namespaces</c> feature is
                <c>false</c>, access by Namespace-qualified names may not be
                available.
              </para>
              <para></para>
              <para>
                The order of attributes in the list is unspecified, and will
                vary from implementation to implementation.
              </para>
              <para></para>
            </summary>
            <seealso cref="!:Attributes" />
            <seealso cref="!:IDeclHandler.AttributeDecl" />
        </member>
        <member name="P:Sax.Net.IAttributes.Length">
            <summary>
              Gets the number of attributes in the list.
              <para></para>
              <para>
                Once you know the number of attributes, you can iterate
                through the list.
              </para>
              <para></para>
            </summary>
            <returns>The number of attributes in the list.</returns>
            <seealso cref="M:Sax.Net.IAttributes.GetUri(System.Int32)" />
            <seealso cref="M:Sax.Net.IAttributes.GetLocalName(System.Int32)" />
            <seealso cref="M:Sax.Net.IAttributes.GetQName(System.Int32)" />
            <seealso cref="M:Sax.Net.IAttributes.GetType(System.Int32)" />
            <seealso cref="M:Sax.Net.IAttributes.GetValue(System.Int32)" />
        </member>
        <member name="M:Sax.Net.IAttributes.GetUri(System.Int32)">
            <summary>
              Look up an attribute's Namespace URI by index.
            </summary>
            <param name="index">
              index The attribute index (zero-based).
            </param>
            <returns>
              The Namespace URI, or the empty string if none
              is available, or null if the index is out of range.
            </returns>
            <seealso cref="P:Sax.Net.IAttributes.Length" />
        </member>
        <member name="M:Sax.Net.IAttributes.GetLocalName(System.Int32)">
            <summary>
              Look up an attribute's local name by index.
            </summary>
            <param name="index">The attribute index (zero-based)</param>
            <returns>
              The local name, or the empty string if Namespace processing is not being performed, or null if the index is
              out of range.
            </returns>
            <seealso cref="P:Sax.Net.IAttributes.Length" />
        </member>
        <member name="M:Sax.Net.IAttributes.GetQName(System.Int32)">
            <summary>
              Look up an attribute's XML qualified (prefixed) name by index.
            </summary>
            <param name="index">The attribute index (zero-based).</param>
            <returns>
              The XML qualified name, or the empty string
              if none is available, or null if the index
              is out of range.
            </returns>
            <seealso cref="P:Sax.Net.IAttributes.Length" />
        </member>
        <member name="M:Sax.Net.IAttributes.GetType(System.Int32)">
            <summary>
              Look up an attribute's type by index.
              <para>
                The attribute type is one of the strings "CDATA", "ID",
                "IDREF", "IDREFS", "NMTOKEN", "NMTOKENS", "ENTITY", "ENTITIES",
                or "NOTATION" (always in upper case).
              </para>
              <para>
                If the parser has not read a declaration for the attribute,
                or if the parser does not report attribute types, then it must
                return the value "CDATA" as stated in the XML 1.0 Recommendation
                (clause 3.3.3, "Attribute-Value Normalization").
              </para>
              <para>
                For an enumerated attribute that is not a notation, the
                parser will report the type as "NMTOKEN".
              </para>
            </summary>
            <param name="index">The attribute index (zero-based).</param>
            <returns>
              The attribute's type as a string, or null if the
              index is out of range.
            </returns>
            <seealso cref="P:Sax.Net.IAttributes.Length" />
        </member>
        <member name="M:Sax.Net.IAttributes.GetValue(System.Int32)">
            <summary>
              Look up an attribute's value by index.
              <para>
                If the attribute value is a list of tokens (IDREFS,
                ENTITIES, or NMTOKENS), the tokens will be concatenated
                into a single string with each token separated by a
                single space.
              </para>
            </summary>
            <param name="index">The attribute index (zero-based).</param>
            <returns>
              @return The attribute's value as a string, or null if the
              index is out of range.
            </returns>
            <seealso cref="P:Sax.Net.IAttributes.Length" />
        </member>
        <member name="M:Sax.Net.IAttributes.GetIndex(System.String,System.String)">
            <summary>
              Look up the index of an attribute by Namespace name.
            </summary>
            <param name="uri">
              The Namespace URI, or the empty string if
              the name has no Namespace URI.
            </param>
            <param name="localName">The attribute's local name.</param>
            <returns>
              The index of the attribute, or -1 if it does not
              appear in the list.
            </returns>
        </member>
        <member name="M:Sax.Net.IAttributes.GetIndex(System.String)">
            <summary>
              Look up the index of an attribute by XML qualified (prefixed) name.
            </summary>
            <param name="qName">The qualified (prefixed) name.</param>
            <returns>
              The index of the attribute, or -1 if it does not
              appear in the list.
            </returns>
        </member>
        <member name="M:Sax.Net.IAttributes.GetType(System.String,System.String)">
            <summary>
              Look up an attribute's type by Namespace name.
              <para>
                See <seealso cref="M:Sax.Net.IAttributes.GetType(System.Int32)" /> for a description
                of the possible types.
              </para>
            </summary>
            <param name="uri">
              The Namespace URI, or the empty string if the
              name has no Namespace URI.
            </param>
            <param name="localName">The local name of the attribute.</param>
            <returns>
              The attribute type as a string, or null if the
              attribute is not in the list or if Namespace
              processing is not being performed.
            </returns>
        </member>
        <member name="M:Sax.Net.IAttributes.GetType(System.String)">
            <summary>
              Look up an attribute's type by XML qualified (prefixed) name.
              <para>
                See <seealso cref="M:Sax.Net.IAttributes.GetType(System.Int32)" /> for a description
                * of the possible types.
              </para>
            </summary>
            <param name="qName">The XML qualified name.</param>
            <returns>
              The attribute type as a string, or null if the
              attribute is not in the list or if qualified names
              are not available.
            </returns>
        </member>
        <member name="M:Sax.Net.IAttributes.GetValue(System.String,System.String)">
            <summary>
              Look up an attribute's value by Namespace name.
              <para>
                See <see cref="M:Sax.Net.IAttributes.GetValue(System.Int32)" /> for a description
                of the possible values.
              </para>
            </summary>
            <param name="uri">
              The Namespace URI, or the empty string if the
              name has no Namespace URI.
            </param>
            <param name="localName">The local name of the attribute.</param>
            <returns>
              The attribute value as a string, or null if the
              attribute is not in the list.
            </returns>
        </member>
        <member name="M:Sax.Net.IAttributes.GetValue(System.String)">
            <summary>
              Look up an attribute's value by XML qualified (prefixed) name.
              <para>
                See <see cref="M:Sax.Net.IAttributes.GetValue(System.Int32)"/> for a description
                of the possible values.
              </para>
            </summary>
            <param name="qName">The XML qualified name.</param>
            <returns>
              The attribute value as a string, or null if the
              attribute is not in the list or if qualified names
              are not available.
            </returns>
        </member>
        <member name="T:Sax.Net.IContentHandler">
            <summary>
              Receive notification of the logical content of a document.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                This is the main interface that most SAX applications
                implement: if the application needs to be informed of basic parsing
                events, it implements this interface and registers an instance with
                the SAX parser using the <see cref="M:Sax.Net.IXmlReader.set_ContentHandler(Sax.Net.IContentHandler)" /> /.
                method. The parser uses the instance to report
                basic document-related events like the start and end of elements
                and character data.
              </para>
              <para>
                The order of events in this interface is very important, and
                mirrors the order of information in the document itself.  For
                example, all of an element's content (character data, processing
                instructions, and/or subelements) will appear, in order, between
                the startElement event and the corresponding endElement event.
              </para>
            </summary>
            <seealso cref="T:Sax.Net.IXmlReader" />
            <seealso cref="T:Sax.Net.IDTDHandler" />
            <seealso cref="T:Sax.Net.IErrorHandler" />
        </member>
        <member name="M:Sax.Net.IContentHandler.SetDocumentLocator(Sax.Net.ILocator)">
            <summary>
              Receive an object for locating the origin of SAX document events.
              <para>
                SAX parsers are strongly encouraged (though not absolutely
                required) to supply a locator: if it does so, it must supply
                the locator to the application by invoking this method before
                invoking any of the other methods in the ContentHandler
                interface.
              </para>
              <para>
                The locator allows the application to determine the end
                position of any document-related event, even if the parser is
                not reporting an error.  Typically, the application will
                use this information for reporting its own errors (such as
                character content that does not match an application's
                business rules).  The information returned by the locator
                is probably not sufficient for use with a search engine.
              </para>
              <para>
                Note that the locator will return correct information only
                during the invocation SAX event callbacks after
                <see cref="M:Sax.Net.IContentHandler.StartDocument"/> returns and before
                <see cref="M:Sax.Net.IContentHandler.EndDocument"/> is called.  The
                application should not attempt to use it at any other time.
              </para>
            </summary>
            <param name="locator">
              an object that can return the location of
              any SAX document event
            </param>
            <seealso cref="T:Sax.Net.ILocator" />
        </member>
        <member name="M:Sax.Net.IContentHandler.StartDocument">
            <summary>
              Receive notification of the beginning of a document.
              <para>
                The SAX parser will invoke this method only once, before any
                other event callbacks (except for <see cref="M:Sax.Net.IContentHandler.SetDocumentLocator(Sax.Net.ILocator)" />).
              </para>
            </summary>
            <exception cref="T:Sax.Net.SAXException">any SAX exception, possibly wrapping another exception</exception>
            <seealso cref="M:Sax.Net.IContentHandler.EndDocument" />
        </member>
        <member name="M:Sax.Net.IContentHandler.EndDocument">
            <summary>
              Receive notification of the end of a document.
              <para>
                <strong>
                  There is an apparent contradiction between the
                  documentation for this method and the documentation for <see cref="M:Sax.Net.IErrorHandler.FatalError(Sax.Net.SAXParseException)" />.
                  Until this ambiguity is
                  resolved in a future major release, clients should make no
                  assumptions about whether <see cref="M:Sax.Net.IContentHandler.EndDocument"/> will or will not be
                  invoked when the parser has reported a <see cref="M:Sax.Net.IErrorHandler.FatalError(Sax.Net.SAXParseException)"/> or thrown
                  an exception.
                </strong>
              </para>
              <para>
                The SAX parser will invoke this method only once, and it will
                be the last method invoked during the parse.  The parser shall
                not invoke this method until it has either abandoned parsing
                (because of an unrecoverable error) or reached the end of
                input.
              </para>
            </summary>
            <exception cref="T:Sax.Net.SAXException">any SAX exception, possibly wrapping another exception</exception>
            <seealso cref="M:Sax.Net.IContentHandler.StartDocument" />
        </member>
        <member name="M:Sax.Net.IContentHandler.StartPrefixMapping(System.String,System.String)">
            <summary>
              Begin the scope of a prefix-URI Namespace mapping.
              <para>
                The information from this event is not necessary for
                normal Namespace processing: the SAX XML reader will
                automatically replace prefixes for element and attribute
                names when the <c>http://xml.org/sax/features/namespaces</c>
                feature is <c>true</c> (the default).
              </para>
              <para>
                There are cases, however, when applications need to
                use prefixes in character data or in attribute values,
                where they cannot safely be expanded automatically; the
                start/endPrefixMapping event supplies the information
                to the application to expand prefixes in those contexts
                itself, if necessary.
              </para>
              <para>
                Note that start/endPrefixMapping events are not
                guaranteed to be properly nested relative to each other:
                all startPrefixMapping events will occur immediately before the
                corresponding <see cref="M:Sax.Net.IContentHandler.StartElement(System.String,System.String,System.String,Sax.Net.IAttributes)" /> event,
                and all <see cref="M:Sax.Net.IContentHandler.EndPrefixMapping(System.String)" />
                events will occur immediately after the corresponding
                <see cref="M:Sax.Net.IContentHandler.EndElement(System.String,System.String,System.String)" /> event,
                but their order is not otherwise
                guaranteed.
              </para>
              <para>
                There should never be start/endPrefixMapping events for the
                "xml" prefix, since it is predeclared and immutable.
              </para>
            </summary>
            <param name="prefix">
              the Namespace prefix being declared.
              An empty string is used for the default element namespace,
              which has no prefix.
            </param>
            <param name="uri">
              the Namespace URI the prefix is mapped to
            </param>
            <exception cref="T:Sax.Net.SAXException">the client may throw an exception during processing</exception>
            <seealso cref="M:Sax.Net.IContentHandler.EndPrefixMapping(System.String)" />
            <seealso cref="M:Sax.Net.IContentHandler.StartElement(System.String,System.String,System.String,Sax.Net.IAttributes)" />
        </member>
        <member name="M:Sax.Net.IContentHandler.EndPrefixMapping(System.String)">
            <summary>
              End the scope of a prefix-URI mapping.
              <para>
                See <see cref="M:Sax.Net.IContentHandler.StartPrefixMapping(System.String,System.String)" /> for
                details.  These events will always occur immediately after the
                corresponding <see cref="M:Sax.Net.IContentHandler.EndElement(System.String,System.String,System.String)" /> event, but the order of
                <see cref="M:Sax.Net.IContentHandler.EndPrefixMapping(System.String)" /> events is not otherwise
                guaranteed.
              </para>
            </summary>
            <param name="prefix">
              the prefix that was being mapped.
              This is the empty string when a default mapping scope ends.
            </param>
            <exception cref="T:Sax.Net.SAXException">the client may throw an exception during processing</exception>
            <seealso cref="M:Sax.Net.IContentHandler.StartPrefixMapping(System.String,System.String)" />
            <seealso cref="M:Sax.Net.IContentHandler.EndElement(System.String,System.String,System.String)" />
        </member>
        <member name="M:Sax.Net.IContentHandler.StartElement(System.String,System.String,System.String,Sax.Net.IAttributes)">
            <summary>
              Receive notification of the beginning of an element.
              <para>
                The Parser will invoke this method at the beginning of every
                element in the XML document; there will be a corresponding
                <see cref="M:Sax.Net.IContentHandler.EndElement(System.String,System.String,System.String)" /> event for every startElement event
                (even when the element is empty). All of the element's content will be
                reported, in order, before the corresponding endElement
                event.
              </para>
              <para>
                This event allows up to three name components for each
                element:
              </para>
              <ol>
                <li>the Namespace URI;</li>
                <li>the local name; and</li>
                <li>the qualified (prefixed) name.</li>
              </ol>
              <para>
                Any or all of these may be provided, depending on the
                values of the <c>http://xml.org/sax/features/namespaces</c>
                and the <c>http://xml.org/sax/features/namespace-prefixes</c>
                properties:
              </para>
              <ul>
                <li>
                  the Namespace URI and local name are required when
                  the namespaces property is <c>true</c> (the default), and are
                  optional when the namespaces property is <c>false</c> (if one is
                  specified, both must be);
                </li>
                <li>
                  the qualified name is required when the namespace-prefixes property
                  is <c>true</c>, and is optional when the namespace-prefixes property
                  is <c>false</c> (the default).
                </li>
              </ul>
              <para>
                Note that the attribute list provided will contain only
                attributes with explicit values (specified or defaulted):
                #IMPLIED attributes will be omitted.  The attribute list
                will contain attributes used for Namespace declarations
                (xmlns* attributes) only if the
                <c>http://xml.org/sax/features/namespace-prefixes</c>
                property is true (it is false by default, and support for a
                true value is optional).
              </para>
              <para>
                Like <see cref="M:Sax.Net.IContentHandler.Characters(System.Char[],System.Int32,System.Int32)" />, attribute values may have
                characters that need more than one <c>char</c> value.
              </para>
            </summary>
            <param name="uri">
              the Namespace URI, or the empty string if the
              element has no Namespace URI or if Namespace
              processing is not being performed
            </param>
            <param name="localName">
              the local name (without prefix), or the
              empty string if Namespace processing is not being
              performed
            </param>
            <param name="qName">
              the qualified name (with prefix), or the
              empty string if qualified names are not available
            </param>
            <param name="atts">
              the attributes attached to the element.  If
              there are no attributes, it shall be an empty
              Attributes object.  The value of this object after
              startElement returns is undefined
            </param>
            <exception cref="T:Sax.Net.SAXException">any SAX exception, possibly wrapping another exception</exception>
            <seealso cref="M:Sax.Net.IContentHandler.EndElement(System.String,System.String,System.String)" />
            <seealso cref="T:Sax.Net.IAttributes" />
            <seealso cref="!:Attributes" />
        </member>
        <member name="M:Sax.Net.IContentHandler.EndElement(System.String,System.String,System.String)">
            <summary>
              Receive notification of the end of an element.
              <para>
                The SAX parser will invoke this method at the end of every
                element in the XML document; there will be a corresponding
                <see cref="M:Sax.Net.IContentHandler.StartElement(System.String,System.String,System.String,Sax.Net.IAttributes)" /> event for every endElement
                event (even when the element is empty).
              </para>
              <para>For information on the names, see startElement.</para>
            </summary>
            <param name="uri">
              the Namespace URI, or the empty string if the
              element has no Namespace URI or if Namespace
              processing is not being performed
            </param>
            <param name="localName">
              the local name (without prefix), or the
              empty string if Namespace processing is not being
              performed
            </param>
            <param name="qName">
              the qualified XML name (with prefix), or the
              empty string if qualified names are not available
            </param>
            <exception cref="T:Sax.Net.SAXException">any SAX exception, possiblywrapping another exception
            </exception>
        </member>
        <member name="M:Sax.Net.IContentHandler.Characters(System.Char[],System.Int32,System.Int32)">
            <summary>
              Receive notification of character data.
              <para>
                The Parser will call this method to report each chunk of
                character data.  SAX parsers may return all contiguous character
                data in a single chunk, or they may split it into several
                chunks; however, all of the characters in any single event
                must come from the same external entity so that the Locator
                provides useful information.
              </para>
              <para>
                The application must not attempt to read from the array
                outside of the specified range.
              </para>
              <para>
                Individual characters may consist of more than one Java
                <c>char</c> value.  There are two important cases where this
                happens, because characters can't be represented in just sixteen bits.
                In one case, characters are represented in a <em>Surrogate Pair</em>,
                using two special Unicode values. Such characters are in the so-called
                "Astral Planes", with a code point above U+FFFF.  A second case involves
                composite characters, such as a base character combining with one or
                more accent characters.
              </para>
              <para>
                Your code should not assume that algorithms using
                <c>char</c>-at-a-time idioms will be working in character
                units; in some cases they will split characters.  This is relevant
                wherever XML permits arbitrary characters, such as attribute values,
                processing instruction data, and comments as well as in data reported
                from this method.  It's also generally relevant whenever Java code
                manipulates internationalized text; the issue isn't unique to XML.
              </para>
              <para>
                Note that some parsers will report whitespace in element
                content using the <see cref="M:Sax.Net.IContentHandler.IgnorableWhitespace(System.Char[],System.Int32,System.Int32)" />
                method rather than this one (validating parsers <em>must</em>
                do so).
              </para>
            </summary>
            <param name="ch">
              the characters from the XML document
            </param>
            <param name="start">
              the start position in the array
            </param>
            <param name="length">
              the number of characters to read from the array
            </param>
            <exception cref="T:Sax.Net.SAXException">any SAX exception, possibly wrapping another exception</exception>
            <seealso cref="M:Sax.Net.IContentHandler.IgnorableWhitespace(System.Char[],System.Int32,System.Int32)" />
            <seealso cref="T:Sax.Net.ILocator" />
        </member>
        <member name="M:Sax.Net.IContentHandler.IgnorableWhitespace(System.Char[],System.Int32,System.Int32)">
            <summary>
              Receive notification of ignorable whitespace in element content.
              <para>
                Validating Parsers must use this method to report each chunk
                of whitespace in element content (see the W3C XML 1.0
                recommendation, section 2.10): non-validating parsers may also
                use this method if they are capable of parsing and using
                content models.
              </para>
              <para>
                SAX parsers may return all contiguous whitespace in a single
                chunk, or they may split it into several chunks; however, all of
                the characters in any single event must come from the same
                external entity, so that the Locator provides useful
                information.
              </para>
              <para>
                The application must not attempt to read from the array
                outside of the specified range.
              </para>
            </summary>
            <param name="ch">
              the characters from the XML document
            </param>
            <param name="start">
              the start position in the array
            </param>
            <param name="length">
              the number of characters to read from the array
            </param>
            <exception cref="T:Sax.Net.SAXException">any SAX exception, possibly wrapping another exception</exception>
            <seealso cref="M:Sax.Net.IContentHandler.Characters(System.Char[],System.Int32,System.Int32)" />
        </member>
        <member name="M:Sax.Net.IContentHandler.ProcessingInstruction(System.String,System.String)">
            <summary>
              Receive notification of a processing instruction.
              <para>
                The Parser will invoke this method once for each processing
                instruction found: note that processing instructions may occur
                before or after the main document element.
              </para>
              <para>
                A SAX parser must never report an XML declaration (XML 1.0,
                section 2.8) or a text declaration (XML 1.0, section 4.3.1)
                using this method.
              </para>
              <para>
                Like <see cref="M:Sax.Net.IContentHandler.Characters(System.Char[],System.Int32,System.Int32)" />, processing instruction
                data may have characters that need more than one <c>char</c>
                value.
              </para>
            </summary>
            <param name="target">
              the processing instruction target
            </param>
            <param name="data">
              the processing instruction data, or null if
              none was supplied.  The data does not include any
              whitespace separating it from the target
            </param>
            <exception cref="T:Sax.Net.SAXException">any SAX exception, possibly wrapping another exception</exception>
        </member>
        <member name="M:Sax.Net.IContentHandler.SkippedEntity(System.String)">
            <summary>
              Receive notification of a skipped entity.
              This is not called for entity references within markup constructs
              such as element start tags or markup declarations.  (The XML
              recommendation requires reporting skipped external entities.
              SAX also reports internal entity expansion/non-expansion, except
              within markup constructs.)
              <para>
                The Parser will invoke this method each time the entity is
                skipped.  Non-validating processors may skip entities if they
                have not seen the declarations (because, for example, the
                entity was declared in an external DTD subset).  All processors
                may skip external entities, depending on the values of the
                <c>http://xml.org/sax/features/external-general-entities</c>
                and the
                <c>http://xml.org/sax/features/external-parameter-entities</c>
                properties.
              </para>
            </summary>
            <param name="name">
              the name of the skipped entity.  If it is a
              parameter entity, the name will begin with '%', and if
              it is the external DTD subset, it will be the string
              "[dtd]"
            </param>
            <exception cref="T:Sax.Net.SAXException">any SAX exception, possibly wrapping another exception</exception>
        </member>
        <member name="T:Sax.Net.IDTDHandler">
            <summary>
              Receive notification of basic DTD-related events.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                If a SAX application needs information about notations and
                unparsed entities, then the application implements this
                interface and registers an instance with the SAX parser using
                the parser's setDTDHandler method.  The parser uses the
                instance to report notation and unparsed entity declarations to
                the application.
              </para>
              <para>
                Note that this interface includes only those DTD events that
                the XML recommendation <em>requires</em> processors to report:
                notation and unparsed entity declarations.
              </para>
              <para>
                The SAX parser may report these events in any order, regardless
                of the order in which the notations and unparsed entities were
                declared; however, all DTD events must be reported after the
                document handler's startDocument event, and before the first
                startElement event.
                (If the <see cref="!:ILexicalHandler" /> is
                used, these events must also be reported before the endDTD event.)
              </para>
              <para>
                It is up to the application to store the information for
                future use (perhaps in a hash table or object tree).
                If the application encounters attributes of type "NOTATION",
                "ENTITY", or "ENTITIES", it can use the information that it
                obtained through this interface to find the entity and/or
                notation corresponding with the attribute value.
              </para>
            </summary>
            <seealso cref="M:Sax.Net.IXmlReader.set_DTDHandler(Sax.Net.IDTDHandler)" />
        </member>
        <member name="M:Sax.Net.IDTDHandler.NotationDecl(System.String,System.String,System.String)">
            <summary>
              Receive notification of a notation declaration event.
              <para>
                It is up to the application to record the notation for later
                reference, if necessary;
                notations may appear as attribute values and in unparsed entity
                declarations, and are sometime used with processing instruction
                target names.
              </para>
              <para>
                At least one of publicId and systemId must be non-null.
                If a system identifier is present, and it is a URL, the SAX
                parser must resolve it fully before passing it to the
                application through this event.
              </para>
              <para>
                There is no guarantee that the notation declaration will be
                reported before any unparsed entities that use it.
              </para>
            </summary>
            <param name="name">
              The notation name.
            </param>
            <param name="publicId">
              The notation's public identifier, or null if
              none was given.
            </param>
            <param name="systemId">
              The notation's system identifier, or null if
              none was given.
            </param>
            <exception cref="T:Sax.Net.SAXException"> Any SAX exception, possibly wrapping another exception.</exception>
            <seealso cref="M:Sax.Net.IDTDHandler.UnparsedEntityDecl(System.String,System.String,System.String,System.String)" />
            <seealso cref="T:Sax.Net.IAttributes" />
        </member>
        <member name="M:Sax.Net.IDTDHandler.UnparsedEntityDecl(System.String,System.String,System.String,System.String)">
            <summary>
              Receive notification of an unparsed entity declaration event.
              <para>
                Note that the notation name corresponds to a notation
                reported by the <see cref="!:#notationDecl" /> event.
                It is up to the application to record the entity for later
                reference, if necessary;
                unparsed entities may appear as attribute values.
              </para>
              <para>
                If the system identifier is a URL, the parser must resolve it
                fully before passing it to the application.
              </para>
            </summary>
            <param name="name">
              The unparsed entity's name.
            </param>
            <param name="publicId">
              The entity's public identifier, or null if none
              was given.
            </param>
            <param name="systemId">
              The entity's system identifier.
            </param>
            <param name="notationName">
              The name of the associated notation.
            </param>
            <exception cref="T:Sax.Net.SAXException">Any SAX exception, possibly wrapping another exception.</exception>
            <seealso cref="M:Sax.Net.IDTDHandler.NotationDecl(System.String,System.String,System.String)" />
            <seealso cref="T:Sax.Net.IAttributes" />
        </member>
        <member name="T:Sax.Net.IEntityResolver">
            <summary>
              Basic interface for resolving entities.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                If a SAX application needs to implement customized handling
                for external entities, it must implement this interface and
                register an instance with the SAX driver using the
                <see cref="M:Sax.Net.IXmlReader.set_EntityResolver(Sax.Net.IEntityResolver)" />
                method.
              </para>
              <para>
                The XML reader will then allow the application to intercept any
                external entities (including the external DTD subset and external
                parameter entities, if any) before including them.
              </para>
              <para>
                Many SAX applications will not need to implement this interface,
                but it will be especially useful for applications that build
                XML documents from databases or other specialised input sources,
                or for applications that use URI types other than URLs.
              </para>
              <para>
                The following resolver would provide the application
                with a special character stream for the entity with the system
                identifier "http://www.myhost.com/today":
              </para>
              <code>
                using Sax.Net;
                  public class MyResolver : IEntityResolver {
                    public InputSource ResolveEntity (string publicId, string systemId)
                    {
                      if (systemId.equals("http://www.myhost.com/today")) {
                        MyReader reader = new MyReader();
                        return new InputSource(reader);
                    } else {
                      return null;
                    }
                  }
                }
              </code>
              <para>
                The application can also use this interface to redirect system
                identifiers to local URIs or to look up replacements in a catalog
                (possibly by using the public identifier).
              </para>
            </summary>
            <seealso cref="P:Sax.Net.IXmlReader.EntityResolver" />
            <seealso cref="T:Sax.Net.InputSource" />
        </member>
        <member name="M:Sax.Net.IEntityResolver.ResolveEntity(System.String,System.String)">
            <summary>
              Allow the application to resolve external entities.
              <para>
                The parser will call this method before opening any external
                entity except the top-level document entity.  Such entities include
                the external DTD subset and external parameter entities referenced
                within the DTD (in either case, only if the parser reads external
                parameter entities), and external general entities referenced
                within the document element (if the parser reads external general
                entities).  The application may request that the parser locate
                the entity itself, that it use an alternative URI, or that it
                use data provided by the application (as a character or byte
                input stream).
              </para>
              <para>
                Application writers can use this method to redirect external
                system identifiers to secure and/or local URIs, to look up
                public identifiers in a catalogue, or to read an entity from a
                database or other input source (including, for example, a dialog
                box).  Neither XML nor SAX specifies a preferred policy for using
                public or system IDs to resolve resources.  However, SAX specifies
                how to interpret any InputSource returned by this method, and that
                if none is returned, then the system ID will be dereferenced as
                a URL.
              </para>
              <para>
                If the system identifier is a URL, the SAX parser must
                resolve it fully before reporting it to the application.
              </para>
            </summary>
            <param name="publicId">
              The public identifier of the external entity
              being referenced, or null if none was supplied.
            </param>
            <param name="systemId">
              The system identifier of the external entity
              being referenced.
            </param>
            <returns>
              An InputSource object describing the new input source,
              or null to request that the parser open a regular
              URI connection to the system identifier.
            </returns>
            <exception cref="T:Sax.Net.SAXException">
              Any SAX exception, possibly
              wrapping another exception.
            </exception>
            <exception cref="!:IOException">
              A .net-specific IO exception,
              possibly the result of creating a new Stream
              or Reader for the InputSource.
            </exception>
            <seealso cref="T:Sax.Net.InputSource" />
        </member>
        <member name="T:Sax.Net.IErrorHandler">
            <summary>
              Basic interface for SAX error handlers.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                If a SAX application needs to implement customized error
                handling, it must implement this interface and then register an
                instance with the XML reader using the
                <see cref="M:Sax.Net.IXmlReader.set_ErrorHandler(Sax.Net.IErrorHandler)" />
                method.  The parser will then report all errors and warnings
                through this interface.
              </para>
              <para>
                <strong>WARNING:</strong> If an application does <em>not</em>
                register an ErrorHandler, XML parsing errors will go unreported,
                except that <em>SAXParseException</em>s will be thrown for fatal errors.
                In order to detect validity errors, an ErrorHandler that does something
                with <see cref="M:Sax.Net.IErrorHandler.Error(Sax.Net.SAXParseException)" /> calls must be registered.
              </para>
              <para>
                For XML processing errors, a SAX driver must use this interface
                in preference to throwing an exception: it is up to the application
                to decide whether to throw an exception for different types of
                errors and warnings.  Note, however, that there is no requirement that
                the parser continue to report additional errors after a call to
                <see cref="M:Sax.Net.IErrorHandler.FatalError(Sax.Net.SAXParseException)" />.  In other words, a SAX driver class
                may throw an exception after reporting any fatalError.
                Also parsers may throw appropriate exceptions for non-XML errors.
                For example, <see cref="M:Sax.Net.IXmlReader.Parse(Sax.Net.InputSource)" /> would throw
                an IOException for errors accessing entities or the document.
              </para>
            </summary>
            <seealso cref="M:Sax.Net.IXmlReader.set_ErrorHandler(Sax.Net.IErrorHandler)" />
            <seealso cref="T:Sax.Net.SAXParseException" />
        </member>
        <member name="M:Sax.Net.IErrorHandler.Warning(Sax.Net.SAXParseException)">
            <summary>
              Receive notification of a warning.
              <para>
                SAX parsers will use this method to report conditions that
                are not errors or fatal errors as defined by the XML
                recommendation.  The default behaviour is to take no
                action.
              </para>
              <para>
                The SAX parser must continue to provide normal parsing events
                after invoking this method: it should still be possible for the
                application to process the document through to the end.
              </para>
              <para>
                Filters may use this method to report other, non-XML warnings
                as well.
              </para>
            </summary>
            <param name="exception">The warning information encapsulated in a SAX parse exception.</param>
            <exception cref="T:Sax.Net.SAXException">Any SAX exception, possibly wrapping another exception.</exception>
            <seealso cref="T:Sax.Net.SAXParseException" />
        </member>
        <member name="M:Sax.Net.IErrorHandler.Error(Sax.Net.SAXParseException)">
            <summary>
              Receive notification of a recoverable error.
              <para>
                This corresponds to the definition of "error" in section 1.2
                of the W3C XML 1.0 Recommendation.  For example, a validating
                parser would use this callback to report the violation of a
                validity constraint.  The default behaviour is to take no
                action.
              </para>
              <para>
                The SAX parser must continue to provide normal parsing
                events after invoking this method: it should still be possible
                for the application to process the document through to the end.
                If the application cannot do so, then the parser should report
                a fatal error even if the XML recommendation does not require
                it to do so.
              </para>
              <para>
                Filters may use this method to report other, non-XML errors
                as well.
              </para>
            </summary>
            <param name="exception">
              The error information encapsulated in a SAX parse exception.
            </param>
            <exception cref="T:Sax.Net.SAXException">Any SAX exception, possibly wrapping another exception.</exception>
            <seealso cref="T:Sax.Net.SAXParseException" />
        </member>
        <member name="M:Sax.Net.IErrorHandler.FatalError(Sax.Net.SAXParseException)">
            <summary>
              Receive notification of a non-recoverable error.
              <para>
                <strong>
                  There is an apparent contradiction between the
                  documentation for this method and the documentation for
                  <see cref="M:Sax.Net.IContentHandler.EndDocument" />.  Until this ambiguity
                  is resolved in a future major release, clients should make no
                  assumptions about whether endDocument() will or will not be
                  invoked when the parser has reported a fatalError() or thrown
                  an exception.
                </strong>
              </para>
              <para>
                This corresponds to the definition of "fatal error" in
                section 1.2 of the W3C XML 1.0 Recommendation.  For example, a
                parser would use this callback to report the violation of a
                well-formedness constraint.
              </para>
              <para>
                The application must assume that the document is unusable
                after the parser has invoked this method, and should continue
                (if at all) only for the sake of collecting additional error
                messages: in fact, SAX parsers are free to stop reporting any
                other events once this method has been invoked.
              </para>
            </summary>
            <param name="exception">The error information encapsulated in a SAX parse exception.</param>
            <exception cref="T:Sax.Net.SAXException">Any SAX exception, possibly wrapping another exception.</exception>
            <seealso cref="T:Sax.Net.SAXParseException" />
        </member>
        <member name="T:Sax.Net.ILocator">
            <summary>
              Interface for associating a SAX event with a document location.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                If a SAX parser provides location information to the SAX
                application, it does so by implementing this interface and then
                passing an instance to the application using the content
                handler's <see cref="M:Sax.Net.IContentHandler.SetDocumentLocator(Sax.Net.ILocator)" /> method.
                The application can use the object to obtain the location of any
                other SAX event in the XML source document.
              </para>
              <para>
                Note that the results returned by the object will be valid only
                during the scope of each callback method: the application
                will receive unpredictable results if it attempts to use the
                locator at any other time, or after parsing completes.
              </para>
              <para>
                SAX parsers are not required to supply a locator, but they are
                very strongly encouraged to do so.  If the parser supplies a
                locator, it must do so before reporting any other document events.
                If no locator has been set by the time the application receives
                the <see cref="M:Sax.Net.IContentHandler.StartDocument" />
                event, the application should assume that a locator is not
                available.
              </para>
            </summary>
            <seealso cref="M:Sax.Net.IContentHandler.SetDocumentLocator(Sax.Net.ILocator)" />
        </member>
        <member name="P:Sax.Net.ILocator.PublicId">
            <summary>
              Return the public identifier for the current document event.
              <para>
                The return value is the public identifier of the document
                entity or of the external parsed entity in which the markup
                triggering the event appears.
              </para>
            </summary>
            <returns>
              A string containing the public identifier, or
              null if none is available.
            </returns>
            <seealso cref="M:Sax.Net.ILocator.get_SystemId" />
        </member>
        <member name="P:Sax.Net.ILocator.SystemId">
            <summary>
              Return the system identifier for the current document event.
              <para>
                The return value is the system identifier of the document
                entity or of the external parsed entity in which the markup
                triggering the event appears.
              </para>
              <para>
                If the system identifier is a URL, the parser must resolve it
                fully before passing it to the application.  For example, a file
                name must always be provided as a <em>file:...</em> URL, and other
                kinds of relative URI are also resolved against their bases.
              </para>
            </summary>
            <returns>
              A string containing the system identifier, or null
              if none is available.
            </returns>
            <seealso cref="M:Sax.Net.ILocator.get_PublicId" />
        </member>
        <member name="P:Sax.Net.ILocator.LineNumber">
            <summary>
              Return the line number where the current document event ends.
              Lines are delimited by line ends, which are defined in
              the XML specification.
              <para>
                <strong>Warning:</strong> The return value from the method
                is intended only as an approximation for the sake of diagnostics;
                it is not intended to provide sufficient information
                to edit the character content of the original XML document.
                In some cases, these "line" numbers match what would be displayed
                as columns, and in others they may not match the source text
                due to internal entity expansion.
              </para>
              <para>
                The return value is an approximation of the line number
                in the document entity or external parsed entity where the
                markup triggering the event appears.
              </para>
              <para>
                If possible, the SAX driver should provide the line position
                of the first character after the text associated with the document
                event.  The first line is line 1.
              </para>
            </summary>
            <returns> The line number, or -1 if none is available.</returns>
            <seealso cref="M:Sax.Net.ILocator.get_ColumnNumber" />
        </member>
        <member name="P:Sax.Net.ILocator.ColumnNumber">
            <summary>
              Return the column number where the current document event ends.
              This is one-based number of Java <c>char</c> values since
              the last line end.
              <para>
                <strong>Warning:</strong> The return value from the method
                is intended only as an approximation for the sake of diagnostics;
                it is not intended to provide sufficient information
                to edit the character content of the original XML document.
                For example, when lines contain combining character sequences, wide
                characters, surrogate pairs, or bi-directional text, the value may
                not correspond to the column in a text editor's display.
              </para>
              <para>
                The return value is an approximation of the column number
                in the document entity or external parsed entity where the
                markup triggering the event appears.
              </para>
              <para>
                If possible, the SAX driver should provide the line position
                of the first character after the text associated with the document
                event.  The first column in each line is column 1.
              </para>
            </summary>
            <returns>The column number, or -1 if none is available.</returns>
            <seealso cref="M:Sax.Net.ILocator.get_LineNumber" />
        </member>
        <member name="T:Sax.Net.InputSource">
            <summary>
              A single input source for an XML entity.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                This class allows a SAX application to encapsulate information
                about an input source in a single object, which may include
                a public identifier, a system identifier, a byte stream (possibly
                with a specified encoding), and/or a character stream.
              </para>
              <para>
                There are two places that the application can deliver an
                input source to the parser: as the argument to the Parser.parse
                method, or as the return value of the EntityResolver.resolveEntity
                method.
              </para>
              <para>
                The SAX parser will use the InputSource object to determine how
                to read XML input.  If there is a character stream available, the
                parser will read that stream directly, disregarding any text
                encoding declaration found in that stream.
                If there is no character stream, but there is
                a byte stream, the parser will use that byte stream, using the
                encoding specified in the InputSource or else (if no encoding is
                specified) autodetecting the character encoding using an algorithm
                such as the one in the XML specification.  If neither a character
                stream nor a
                byte stream is available, the parser will attempt to open a URL
                connection to the resource identified by the system
                identifier.
              </para>
              <para>
                An InputSource object belongs to the application: the SAX parser
                shall never modify it in any way (it may modify a copy if
                necessary).  However, standard processing of both byte and
                character streams is to close them on as part of end-of-parse cleanup,
                so applications should not attempt to re-use such streams after they
                have been handed to a parser.
              </para>
            </summary>
            <seealso cref="M:Sax.Net.IXmlReader.Parse(Sax.Net.InputSource)" />
            <seealso cref="M:Sax.Net.IEntityResolver.ResolveEntity(System.String,System.String)" />
            <seealso cref="T:System.IO.Stream" />
            <seealso cref="T:System.IO.TextReader" />
        </member>
        <member name="M:Sax.Net.InputSource.#ctor">
            <summary>
              Zero-argument default constructor.
            </summary>
            <seealso cref="P:Sax.Net.InputSource.PublicId" />
            <seealso cref="P:Sax.Net.InputSource.SystemId" />
            <seealso cref="P:Sax.Net.InputSource.Stream" />
            <seealso cref="P:Sax.Net.InputSource.Reader" />
            <seealso cref="P:Sax.Net.InputSource.Encoding" />
        </member>
        <member name="M:Sax.Net.InputSource.#ctor(System.String)">
            <summary>
              Create a new input source with a system identifier.
              <para>
                Applications may use PublicId to include a
                public identifier as well, or Encoding to specify
                the character encoding, if known.
              </para>
              <para>
                If the system identifier is a URL, it must be fully
                resolved (it may not be a relative URL).
              </para>
            </summary>
            <param name="systemId">
              The system identifier (URI).
            </param>
            <seealso cref="P:Sax.Net.InputSource.PublicId" />
            <seealso cref="P:Sax.Net.InputSource.SystemId" />
            <seealso cref="P:Sax.Net.InputSource.Stream" />
            <seealso cref="P:Sax.Net.InputSource.Encoding" />
            <seealso cref="P:Sax.Net.InputSource.Reader" />
        </member>
        <member name="M:Sax.Net.InputSource.#ctor(System.IO.Stream)">
            <summary>
              Create a new input source with a byte stream.
              <para>
                Application writers should use SystemId to provide a base
                for resolving relative URIs, may use PublicId to include a
                public identifier, and may use Encoding to specify the object's
                character encoding.
              </para>
            </summary>
            <param name="stream">
              The raw stream containing the document.
            </param>
            <seealso cref="P:Sax.Net.InputSource.PublicId" />
            <seealso cref="P:Sax.Net.InputSource.SystemId" />
            <seealso cref="P:Sax.Net.InputSource.Encoding" />
            <seealso cref="P:Sax.Net.InputSource.Stream" />
            <seealso cref="P:Sax.Net.InputSource.Reader" />
        </member>
        <member name="M:Sax.Net.InputSource.#ctor(System.IO.TextReader)">
            <summary>
              Create a new input source with a character stream.
              <para>
                Application writers should use SystemId to provide a base
                for resolving relative URIs, and may use PublicId to include a
                public identifier.
              </para>
              <para>The character stream shall not include a byte order mark.</para>
            </summary>
            <seealso cref="M:Sax.Net.InputSource.set_PublicId(System.String)" />
            <seealso cref="M:Sax.Net.InputSource.set_SystemId(System.String)" />
            <seealso cref="M:Sax.Net.InputSource.set_Stream(System.IO.Stream)" />
            <seealso cref="M:Sax.Net.InputSource.set_Reader(System.IO.TextReader)" />
        </member>
        <member name="P:Sax.Net.InputSource.PublicId">
            <summary>
              Get or sets the public identifier for this input source.
              <para>
                The public identifier is always optional: if the application
                writer includes one, it will be provided as part of the
                location information.
              </para>
            </summary>
            <returns>
              The public identifier, or null if none was supplied.
            </returns>
            <seealso cref="P:Sax.Net.ILocator.PublicId" />
            <seealso cref="P:Sax.Net.SAXParseException.PublicId" />
        </member>
        <member name="P:Sax.Net.InputSource.SystemId">
            <summary>
              Get or sets the system identifier for this input source.
              <para>
                The Encoding property will return the character encoding
                of the object pointed to, or null if unknown.
              </para>
              <para>If the system ID is a URL, it will be fully resolved.</para>
              <para>
                The system identifier is optional if there is a byte stream
                or a character stream, but it is still useful to provide one,
                since the application can use it to resolve relative URIs
                and can include it in error messages and warnings (the parser
                will attempt to open a connection to the URI only if
                there is no byte stream or character stream specified).
              </para>
              <para>
                If the application knows the character encoding of the
                object pointed to by the system identifier, it can register
                the encoding using the setEncoding method.
              </para>
              <para>
                If the system identifier is a URL, it must be fully
                resolved (it may not be a relative URL).
              </para>
            </summary>
            <returns>The system identifier, or null if none was supplied.</returns>
            <seealso cref="P:Sax.Net.InputSource.Encoding" />
            <seealso cref="P:Sax.Net.InputSource.SystemId" />
            <seealso cref="P:Sax.Net.ILocator.SystemId" />
            <seealso cref="P:Sax.Net.SAXParseException.SystemId" />
        </member>
        <member name="P:Sax.Net.InputSource.Stream">
            <summary>
              Get or sets the byte stream for this input source.
              <para>
                The getEncoding method will return the character
                encoding for this byte stream, or null if unknown.
              </para>
              <para>
                The SAX parser will ignore this if there is also a character
                stream specified, but it will use a byte stream in preference
                to opening a URI connection itself.
              </para>
              <para>
                If the application knows the character encoding of the
                byte stream, it should set it with the setEncoding method.
              </para>
            </summary>
            <returns>The byte stream, or null if none was supplied.</returns>
            <seealso cref="P:Sax.Net.InputSource.Encoding" />
            <seealso cref="P:Sax.Net.InputSource.Stream" />
            <seealso cref="P:Sax.Net.InputSource.Encoding" />
            <seealso cref="T:System.IO.Stream" />
        </member>
        <member name="P:Sax.Net.InputSource.Encoding">
            <summary>
              Get or sets the character encoding for a byte stream or URI.
              This value will be ignored when the application provides a
              character stream.
              <para>
                The encoding must be a string acceptable for an
                XML encoding declaration (see section 4.3.3 of the XML 1.0
                recommendation).
              </para>
              <para>
                This method has no effect when the application provides a
                character stream.
              </para>
            </summary>
            <returns>The encoding, or null if none was supplied.</returns>
            <seealso cref="P:Sax.Net.InputSource.SystemId" />
            <seealso cref="P:Sax.Net.InputSource.Stream" />
            <seealso cref="P:Sax.Net.InputSource.Encoding" />
        </member>
        <member name="P:Sax.Net.InputSource.Reader">
            <summary>
              Get or sets the character stream for this input source.
              Set the character stream for this input source.
              <para>
                If there is a character stream specified, the SAX parser
                will ignore any byte stream and will not attempt to open
                a URI connection to the system identifier.
              </para>
            </summary>
            <returns>The character stream, or null if none was supplied.</returns>
            <seealso cref="P:Sax.Net.InputSource.Stream" />
            <seealso cref="T:System.IO.TextReader" />
        </member>
        <member name="T:Sax.Net.IXmlFilter">
            <summary>
              Interface for an XML filter.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                An XML filter is like an XML reader, except that it obtains its
                events from another XML reader rather than a primary source like
                an XML document or database.  Filters can modify a stream of
                events as they pass on to the final application.
              </para>
              <para>
                The XMLFilterImpl helper class provides a convenient base
                for creating SAX2 filters, by passing on all <see cref="T:Sax.Net.IEntityResolver" />,
                <see cref="T:Sax.Net.IContentHandler" /> and <see cref="T:Sax.Net.IErrorHandler" /> events automatically.
              </para>
            </summary>
            <seealso cref="!:XmlFilter" />
        </member>
        <member name="P:Sax.Net.IXmlFilter.Parent">
            <summary>
              Get or sets the parent reader.
              <para>
                This method allows the application to query the parent
                reader (which may be another filter).  It is generally a
                bad idea to perform any operations on the parent reader
                directly: they should all pass through this filter.
              </para>
              <para>
                This method allows the application to link the filter to
                a parent reader (which may be another filter).  The argument
                may not be null.
              </para>
            </summary>
            <returns>The parent filter, or null if none has been set.</returns>
        </member>
        <member name="T:Sax.Net.IXmlReader">
            <summary>
              Interface for reading an XML document using callbacks.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                <strong>Note:</strong> despite its name, this interface does
                <em>not</em> extend the standard .net <see cref="!:TextReader" /> interface,
                because reading XML is a fundamentally different activity
                than reading character data.
              </para>
              <para>
                XMLReader is the interface that an XML parser's SAX2 driver must
                implement.  This interface allows an application to set and
                query features and properties in the parser, to register
                event handlers for document processing, and to initiate
                a document parse.
              </para>
              <para>
                All SAX interfaces are assumed to be synchronous: the
                <see cref="M:Sax.Net.IXmlReader.Parse(System.String)" /> methods must not return until parsing
                is complete, and readers must wait for an event-handler callback
                to return before reporting the next event.
              </para>
              <ol>
                <li>
                  it adds a standard way to query and set features and
                  properties; and
                </li>
                <li>
                  it adds Namespace support, which is required for many
                  higher-level XML standards.
                </li>
              </ol>
            </summary>
            <seealso cref="T:Sax.Net.IXmlFilter" />
        </member>
        <member name="P:Sax.Net.IXmlReader.EntityResolver">
            <summary>
              Gets or sets the current entity resolver.
              <para>
                If the application does not register an entity resolver,
                the XMLReader will perform its own default resolution.
              </para>
              <para>
                Applications may register a new or different resolver in the
                middle of a parse, and the SAX parser must begin using the new
                resolver immediately.
              </para>
            </summary>
            <returns>The current entity resolver, or null if none has been registered.</returns>
        </member>
        <member name="P:Sax.Net.IXmlReader.DTDHandler">
            <summary>
              Gets or sets the current DTD handler.
              <para>
                If the application does not register a DTD handler, all DTD
                events reported by the SAX parser will be silently ignored.
              </para>
              <para>
                Applications may register a new or different handler in the
                middle of a parse, and the SAX parser must begin using the new
                handler immediately.
              </para>
            </summary>
            <returns> The current DTD handler, or null if none has been registered.</returns>
        </member>
        <member name="P:Sax.Net.IXmlReader.ContentHandler">
            <summary>
              Gets or sets the current content handler.
              <para>
                If the application does not register a content handler, all
                content events reported by the SAX parser will be silently
                ignored.
              </para>
              <para>
                Applications may register a new or different handler in the
                middle of a parse, and the SAX parser must begin using the new
                handler immediately.
              </para>
            </summary>
            <returns>The current content handler, or null if none has been registered.</returns>
        </member>
        <member name="P:Sax.Net.IXmlReader.ErrorHandler">
            <summary>
              Gets or sets the current error handler.
              <para>
                If the application does not register an error handler, all
                error events reported by the SAX parser will be silently
                ignored; however, normal processing may not continue.  It is
                highly recommended that all SAX applications implement an
                error handler to avoid unexpected bugs.
              </para>
              <para>
                Applications may register a new or different handler in the
                middle of a parse, and the SAX parser must begin using the new
                handler immediately.
              </para>
            </summary>
            <returns>The current error handler, or null if none  has been registered.</returns>
        </member>
        <member name="M:Sax.Net.IXmlReader.GetFeature(System.String)">
            <summary>
              Look up the value of a feature flag.
              <para>
                The feature name is any fully-qualified URI.  It is
                possible for an XMLReader to recognize a feature name but
                temporarily be unable to return its value.
                Some feature values may be available only in specific
                contexts, such as before, during, or after a parse.
                Also, some feature values may not be programmatically accessible.
                There is no implementation-independent way to expose whether the underlying
                parser is performing validation, expanding external entities,
                and so forth.)
              </para>
              <para>
                All XMLReaders are required to recognize the
                http://xml.org/sax/features/namespaces and the
                http://xml.org/sax/features/namespace-prefixes feature names.
              </para>
              <para>
                Implementors are free (and encouraged) to invent their own features,
                using names built on their own URIs.
              </para>
            </summary>
            <param name="name">
              The feature name, which is a fully-qualified URI.
            </param>
            <returns>The current value of the feature (true or false).</returns>
            <exception cref="T:Sax.Net.SAXNotRecognizedException">If the feature value can't be assigned or retrieved.</exception>
            <exception cref="T:Sax.Net.SAXNotSupportedException">
              When the XMLReader recognizes the feature name but cannot
              determine its value at this time.
            </exception>
            <seealso cref="M:Sax.Net.IXmlReader.SetFeature(System.String,System.Boolean)" />
        </member>
        <member name="M:Sax.Net.IXmlReader.SetFeature(System.String,System.Boolean)">
            <summary>
              Set the value of a feature flag.
              <para>
                The feature name is any fully-qualified URI.  It is
                possible for an XMLReader to expose a feature value but
                to be unable to change the current value.
                Some feature values may be immutable or mutable only
                in specific contexts, such as before, during, or after
                a parse.
              </para>
              <para>
                All XMLReaders are required to support setting
                http://xml.org/sax/features/namespaces to true and
                http://xml.org/sax/features/namespace-prefixes to false.
              </para>
            </summary>
            <param name="name">
              The feature name, which is a fully-qualified URI.
            </param>
            <param name="value">
              The requested value of the feature (true or false).
            </param>
            <exception cref="T:Sax.Net.SAXNotRecognizedException">
              If the feature value can't be assigned or retrieved.
            </exception>
            <exception cref="T:Sax.Net.SAXNotSupportedException">
              When the XMLReader recognizes the feature name but cannot set the requested value.
            </exception>
            <seealso cref="M:Sax.Net.IXmlReader.GetFeature(System.String)" />
        </member>
        <member name="M:Sax.Net.IXmlReader.GetProperty(System.String)">
            <summary>
              Look up the value of a property.
              <para>
                The property name is any fully-qualified URI.  It is
                possible for an XMLReader to recognize a property name but
                temporarily be unable to return its value.
                Some property values may be available only in specific
                contexts, such as before, during, or after a parse.
              </para>
              <para>
                XMLReaders are not required to recognize any specific
                property names, though an initial core set is documented for
                SAX2.
              </para>
              <para>
                Implementors are free (and encouraged) to invent their own properties,
                using names built on their own URIs.
              </para>
            </summary>
            <param name="name">
              The property name, which is a fully-qualified URI.
            </param>
            <returns>The current value of the property.</returns>
            <exception cref="T:Sax.Net.SAXNotRecognizedException">
              If the property value can't be assigned or retrieved.
            </exception>
            <exception cref="T:Sax.Net.SAXNotSupportedException">
              When the XMLReader recognizes the property name but cannot determine its value at this time.
            </exception>
            <seealso cref="M:Sax.Net.IXmlReader.SetProperty(System.String,System.Object)" />
        </member>
        <member name="M:Sax.Net.IXmlReader.SetProperty(System.String,System.Object)">
            <summary>
              Set the value of a property.
              <para>
                The property name is any fully-qualified URI.  It is
                possible for an XMLReader to recognize a property name but
                to be unable to change the current value.
                Some property values may be immutable or mutable only
                in specific contexts, such as before, during, or after
                a parse.
              </para>
              <para>
                XMLReaders are not required to recognize setting
                any specific property names, though a core set is defined by
                SAX2.
              </para>
              <para>
                This method is also the standard mechanism for setting
                extended handlers.
              </para>
            </summary>
            <param name="name">
              The property name, which is a fully-qualified URI.
            </param>
            <param name="value">
              The requested value for the property.
            </param>
            <exception cref="T:Sax.Net.SAXNotRecognizedException">
              If the property value can't be assigned or retrieved.
            </exception>
            <exception cref="T:Sax.Net.SAXNotSupportedException">
              When the XMLReader recognizes the property name but cannot set the requested value.
            </exception>
        </member>
        <member name="M:Sax.Net.IXmlReader.Parse(Sax.Net.InputSource)">
            <summary>
              Parse an XML document.
              <para>
                The application can use this method to instruct the XML
                reader to begin parsing an XML document from any valid input
                source (a character stream, a byte stream, or a URI).
              </para>
              <para>
                Applications may not invoke this method while a parse is in
                progress (they should create a new XMLReader instead for each
                nested XML document).  Once a parse is complete, an
                application may reuse the same XMLReader object, possibly with a
                different input source.
                Configuration of the XMLReader object (such as handler bindings and
                values established for feature flags and properties) is unchanged
                by completion of a parse, unless the definition of that aspect of
                the configuration explicitly specifies other behavior.
                (For example, feature flags or properties exposing
                characteristics of the document being parsed.)
              </para>
              <para>
                During the parse, the XMLReader will provide information
                about the XML document through the registered event
                handlers.
              </para>
              <para>
                This method is synchronous: it will not return until parsing
                has ended.  If a client application wants to terminate
                parsing early, it should throw an exception.
              </para>
            </summary>
            <param name="input">
              The input source for the top-level of the
              XML document.
            </param>
            <exception cref="T:Sax.Net.SAXException">
              Any SAX exception, possibly wrapping another exception.
            </exception>
            <exception cref="!:IOException">
              An IO exception from the parser,
              possibly from a byte stream or character stream
              supplied by the application.
            </exception>
            <seealso cref="T:Sax.Net.InputSource" />
            <seealso cref="M:Sax.Net.IXmlReader.Parse(System.String)" />
            <seealso cref="P:Sax.Net.IXmlReader.EntityResolver" />
            <seealso cref="P:Sax.Net.IXmlReader.DTDHandler" />
            <seealso cref="P:Sax.Net.IXmlReader.ContentHandler" />
            <seealso cref="P:Sax.Net.IXmlReader.ErrorHandler" />
        </member>
        <member name="M:Sax.Net.IXmlReader.Parse(System.String)">
            <summary>
              Parse an XML document from a system identifier (URI).
              <para>
                This method is a shortcut for the common case of reading a
                document from a system identifier.  It is the exact
                equivalent of the following:
              </para>
              <code>
                Parse(new InputSource(systemId));
              </code>
              <para>
                If the system identifier is a URL, it must be fully resolved
                by the application before it is passed to the parser.
              </para>
            </summary>
            <param name="systemId">
              The system identifier (URI).
            </param>
            <exception cref="T:Sax.Net.SAXException">
              Any SAX exception, possibly
              wrapping another exception.
            </exception>
            <exception cref="!:IOException">
              An IO exception from the parser,
              possibly from a byte stream or character stream
              supplied by the application.
            </exception>
            <seealso cref="M:Sax.Net.IXmlReader.Parse(Sax.Net.InputSource)" />
        </member>
        <member name="T:Sax.Net.SAXException">
            <summary>
              Encapsulate a general SAX error or warning.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                This class can contain basic error or warning information from
                either the XML parser or the application: a parser writer or
                application writer can subclass it to provide additional
                functionality.  SAX handlers may throw this exception or
                any exception subclassed from it.
              </para>
              <para>
                If the application needs to pass through other types of
                exceptions, it must wrap those exceptions in a SAXException
                or an exception derived from a SAXException.
              </para>
              <para>
                If the parser or application needs to include information about a
                specific location in an XML document, it should use the
                <see cref="T:Sax.Net.SAXParseException" /> subclass.
              </para>
            </summary>
            <seealso cref="T:Sax.Net.SAXParseException" />
        </member>
        <member name="M:Sax.Net.SAXException.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class.
            </summary>
        </member>
        <member name="M:Sax.Net.SAXException.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:Sax.Net.SAXException.#ctor(System.String,System.Exception)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message and a
              reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception. </param>
            <param name="innerException">
              The exception that is the cause of the current exception, or a null reference (Nothing in
              Visual Basic) if no inner exception is specified.
            </param>
        </member>
        <member name="M:Sax.Net.SAXException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class with serialized data.
            </summary>
            <param name="info">
              The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
              data about the exception being thrown.
            </param>
            <param name="context">
              The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
              information about the source or destination.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
              The class name is null or
              <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
        </member>
        <member name="T:Sax.Net.SAXNotRecognizedException">
            <summary>
              Exception class for an unrecognized identifier.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                An XMLReader will throw this exception when it finds an
                unrecognized feature or property identifier; SAX applications and
                extensions may use this class for other, similar purposes.
              </para>
            </summary>
            <seealso cref="T:Sax.Net.SAXNotSupportedException" />
        </member>
        <member name="M:Sax.Net.SAXNotRecognizedException.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class.
            </summary>
        </member>
        <member name="M:Sax.Net.SAXNotRecognizedException.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:Sax.Net.SAXNotRecognizedException.#ctor(System.String,System.Exception)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message and a
              reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception. </param>
            <param name="innerException">
              The exception that is the cause of the current exception, or a null reference (Nothing in
              Visual Basic) if no inner exception is specified.
            </param>
        </member>
        <member name="M:Sax.Net.SAXNotRecognizedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class with serialized data.
            </summary>
            <param name="info">
              The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
              data about the exception being thrown.
            </param>
            <param name="context">
              The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
              information about the source or destination.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
              The class name is null or
              <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
        </member>
        <member name="T:Sax.Net.SAXNotSupportedException">
            <summary>
              Exception class for an unsupported operation.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                An XMLReader will throw this exception when it recognizes a
                feature or property identifier, but cannot perform the requested
                operation (setting a state or value).  Other SAX2 applications and
                extensions may use this class for similar purposes.
              </para>
            </summary>
            <seealso cref="T:Sax.Net.SAXNotRecognizedException" />
        </member>
        <member name="M:Sax.Net.SAXNotSupportedException.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class.
            </summary>
        </member>
        <member name="M:Sax.Net.SAXNotSupportedException.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:Sax.Net.SAXNotSupportedException.#ctor(System.String,System.Exception)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message and a
              reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception. </param>
            <param name="innerException">
              The exception that is the cause of the current exception, or a null reference (Nothing in
              Visual Basic) if no inner exception is specified.
            </param>
        </member>
        <member name="M:Sax.Net.SAXNotSupportedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class with serialized data.
            </summary>
            <param name="info">
              The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
              data about the exception being thrown.
            </param>
            <param name="context">
              The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
              information about the source or destination.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
              The class name is null or
              <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
        </member>
        <member name="T:Sax.Net.SAXParseException">
            <summary>
              Encapsulate an XML parse error or warning.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                This exception may include information for locating the error
                in the original XML document, as if it came from a <see cref="T:Sax.Net.ILocator" />object.
                Note that although the application will receive a SAXParseException as the argument to the handlers
                in the <see cref="T:Sax.Net.IErrorHandler" /> interface,
                the application is not actually required to throw the exception;
                instead, it can simply read the information in it and take a
                different action.
              </para>
              <para>
                Since this exception is a subclass of <see cref="T:Sax.Net.SAXException" />
                it inherits the ability to wrap another exception.
              </para>
            </summary>
            <seealso cref="T:Sax.Net.SAXException" />
            <seealso cref="T:Sax.Net.ILocator" />
            <seealso cref="T:Sax.Net.IErrorHandler" />
        </member>
        <member name="M:Sax.Net.SAXParseException.#ctor(System.String,Sax.Net.ILocator)">
            <summary>
              Create a new SAXParseException from a message and a Locator.
              <para>
                This constructor is especially useful when an application is
                creating its own exception from within a <see cref="T:Sax.Net.IContentHandler" /> callback.
              </para>
            </summary>
            <param name="message">
              The error or warning message.
            </param>
            <param name="locator">
              The locator object for the error or warning (may be null).
            </param>
            <seealso cref="T:Sax.Net.ILocator" />
        </member>
        <member name="M:Sax.Net.SAXParseException.#ctor(System.String,Sax.Net.ILocator,System.Exception)">
            <summary>
              Wrap an existing exception in a SAXParseException.
              <para>
                This constructor is especially useful when an application is
                creating its own exception from within a <see cref="!:org.xml.sax.ContentHandler" /> callback,
                and needs to wrap an existing exception that is not a
                subclass of <see cref="T:Sax.Net.SAXException" />.
              </para>
            </summary>
            <param name="message">
              The error or warning message, or null to
              use the message from the embedded exception.
            </param>
            <param name="locator">
              The locator object for the error or warning (may be null).
            </param>
            <param name="ex">Any exception.</param>
            <seealso cref="T:Sax.Net.ILocator" />
        </member>
        <member name="M:Sax.Net.SAXParseException.#ctor(System.String,System.String,System.String,System.Int64,System.Int64)">
            <summary>
              Create a new SAXParseException.
              <para>This constructor is most useful for parser writers.</para>
              <para>
                All parameters except the message are as if
                they were provided by a <see cref="T:Sax.Net.ILocator" />.  For example, if the
                system identifier is a URL (including relative filename), the
                caller must resolve it fully before creating the exception.
              </para>
            </summary>
            <param name="message">
              The error or warning message.
            </param>
            <param name="publicId">
              The public identifier of the entity that generated the error or warning.
            </param>
            <param name="systemId">
              The system identifier of the entity that generated the error or warning.
            </param>
            <param name="lineNumber">
              The line number of the end of the text that caused the error or warning.
            </param>
            <param name="columnNumber">
              The column number of the end of the text that cause the error or warning.
            </param>
        </member>
        <member name="M:Sax.Net.SAXParseException.#ctor(System.String,System.String,System.String,System.Int64,System.Int64,System.Exception)">
            <summary>
              Create a new SAXParseException with an embedded exception.
              <para>
                This constructor is most useful for parser writers who
                need to wrap an exception that is not a subclass of
                <see cref="T:Sax.Net.SAXException" />.
              </para>
              <para>
                All parameters except the message and exception are as if
                they were provided by a <see cref="T:Sax.Net.ILocator" />.  For example, if the
                system identifier is a URL (including relative filename), the
                caller must resolve it fully before creating the exception.
              </para>
            </summary>
            <param name="message">The error or warning message, or null to use the message from the embedded exception.</param>
            <param name="publicId">The public identifier of the entity that generated the error or warning.</param>
            <param name="systemId">The system identifier of the entity that generated the error or warning.</param>
            <param name="lineNumber">The line number of the end of the text that caused the error or warning.</param>
            <param name="columnNumber">The column number of the end of the text that cause the error or warning.</param>
            <param name="ex">Another exception to embed in this one.</param>
        </member>
        <member name="M:Sax.Net.SAXParseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class with serialized data.
            </summary>
            <param name="info">
              The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
              data about the exception being thrown.
            </param>
            <param name="context">
              The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
              information about the source or destination.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
              The class name is null or
              <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
        </member>
        <member name="P:Sax.Net.SAXParseException.PublicId">
            <summary>
              Get the public identifier of the entity where the exception occurred.
            </summary>
            ///
            <returns>A string containing the public identifier, or null if none is available.</returns>
            <seealso cref="P:Sax.Net.ILocator.PublicId" />
        </member>
        <member name="P:Sax.Net.SAXParseException.SystemId">
            <summary>
              Get the system identifier of the entity where the exception occurred.
              <para>
                If the system identifier is a URL, it will have been resolved
                fully.
              </para>
            </summary>
            <returns> A string containing the system identifier, or null if none is available.</returns>
            <seealso cref="P:Sax.Net.ILocator.SystemId" />
        </member>
        <member name="P:Sax.Net.SAXParseException.LineNumber">
            <summary>
              The line number of the end of the text where the exception occurred.
              <para>The first line is line 1.</para>
            </summary>
            <returns>An integer representing the line number, or -1 if none is available.</returns>
            <seealso cref="P:Sax.Net.ILocator.LineNumber" />
        </member>
        <member name="P:Sax.Net.SAXParseException.ColumnNumber">
            <summary>
              The column number of the end of the text where the exception occurred.
              <para>The first column in a line is position 1.</para>
            </summary>
            <returns>An integer representing the column number, or -1 if none is available.</returns>
            <seealso cref="P:Sax.Net.ILocator.ColumnNumber" />
        </member>
        <member name="M:Sax.Net.SAXParseException.Init(System.String,System.String,System.Int64,System.Int64)">
            <summary>
              Internal initialization method.
            </summary>
            <param name="publicId">The public identifier of the entity which generated the exception, or null.</param>
            <param name="systemId">The system identifier of the entity which generated the exception, or null.</param>
            <param name="lineNumber">The line number of the error, or -1.</param>
            <param name="columnNumber">The column number of the error, or -1.</param>
        </member>
        <member name="T:Sax.Net.Ext.Attributes2">
            <summary>
              SAX2 extension helper for additional Attributes information,
              implementing the <see cref="T:Sax.Net.Ext.Attributes2" /> interface.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
              </blockquote>
              <para>This is not part of core-only SAX2 distributions.</para>
              <para>
                The <em>specified</em> flag for each attribute will always
                be true, unless it has been set to false in the copy constructor
                or using <see cref="M:Sax.Net.Ext.Attributes2.SetSpecified(System.Int32,System.Boolean)" />.
                Similarly, the <em>declared</em> flag for each attribute will
                always be false, except for defaulted attributes (<em>specified</em>
                is false), non-CDATA attributes, or when it is set to true using
                <see cref="M:Sax.Net.Ext.Attributes2.SetDeclared(System.Int32,System.Boolean)" />.
                If you change an attribute's type by hand, you may need to modify
                its <em>declared</em> flag to match.
              </para>
            </summary>
        </member>
        <member name="M:Sax.Net.Ext.Attributes2.#ctor">
            <summary>
              Construct a new, empty Attributes2 object.
            </summary>
        </member>
        <member name="M:Sax.Net.Ext.Attributes2.#ctor(Sax.Net.IAttributes)">
            <summary>
              Copy an existing Attributes or Attributes2 object.
              If the object implements Attributes2, values of the
              <em>specified</em> and <em>declared</em> flags for each
              attribute are copied.
              Otherwise the flag values are defaulted to assume no DTD was used,
              unless there is evidence to the contrary (such as attributes with
              type other than CDATA, which must have been <em>declared</em>).
              <para>
                This constructor is especially useful inside a
                <see cref="M:Sax.Net.IContentHandler.StartElement(System.String,System.String,System.String,Sax.Net.IAttributes)" /> event.
              </para>
            </summary>
            <param name="atts">
              The existing Attributes object.
            </param>
        </member>
        <member name="T:Sax.Net.Ext.DefaultHandler2">
            <summary>
              This class extends the SAX2 base handler class to support the
              SAX2 <see cref="T:Sax.Net.Ext.ILexicalHandler" />, {@link DeclHandler}, and
              <see cref="T:Sax.Net.Ext.IEntityResolver2" /> extensions.  Except for overriding the
              original SAX1 <see cref="M:Sax.Net.Helpers.DefaultHandler.ResolveEntity(System.String,System.String)" />
              method the added handler methods just return.  Subclassers may
              override everything on a method-by-method basis.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
              </blockquote>
              <para>
                <em>Note:</em> this class might yet learn that the
                <em>ContentHandler.setDocumentLocator()</em> call might be passed a
                <see cref="T:Sax.Net.Ext.ILocator2" /> object, and that the
                <em>ContentHandler.startElement()</em> call might be passed a
                <see cref="T:Sax.Net.Ext.IAttributes2" /> object.
              </para>
            </summary>
        </member>
        <member name="T:Sax.Net.Ext.IAttributes2">
            <summary>
              SAX2 extension to augment the per-attribute information
              provided though <see cref="T:Sax.Net.IAttributes" />.
              If an implementation supports this extension, the attributes
              provided in <see cref="M:Sax.Net.IContentHandler.StartElement(System.String,System.String,System.String,Sax.Net.IAttributes)" /> will implement this interface,
              and the <em>http://xml.org/sax/features/use-attributes2</em>
              feature flag will have the value <em>true</em>.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
              </blockquote>
              <para>
                XMLReader implementations are not required to support this
                information, and it is not part of core-only SAX2 distributions.
              </para>
              <para>
                Note that if an attribute was defaulted (<em>!isSpecified()</em>)
                it will of necessity also have been declared (<em>isDeclared()</em>)
                in the DTD.
                Similarly if an attribute's type is anything except CDATA, then it
                must have been declared.
              </para>
            </summary>
        </member>
        <member name="M:Sax.Net.Ext.IAttributes2.IsDeclared(System.Int32)">
            <summary>
              Returns false unless the attribute was declared in the DTD.
              This helps distinguish two kinds of attributes that SAX reports
              as CDATA:  ones that were declared (and hence are usually valid),
              and those that were not (and which are never valid).
            </summary>
            <param name="index">
              The attribute index (zero-based).
            </param>
            <returns>
              <c>true</c> if the attribute was declared in the DTD,
              <c>false</c> otherwise.
            </returns>
            <exception cref="!:IndexOutOfRangeException">
              When the supplied index does not identify an attribute.
            </exception>
        </member>
        <member name="M:Sax.Net.Ext.IAttributes2.IsDeclared(System.String)">
            <summary>
              Returns false unless the attribute was declared in the DTD.
              This helps distinguish two kinds of attributes that SAX reports
              as CDATA:  ones that were declared (and hence are usually valid),
              and those that were not (and which are never valid).
            </summary>
            <param name="qName">
              The XML qualified (prefixed) name.
            </param>
            <returns>
              <c>true</c> if the attribute was declared in the DTD,
              <c>false</c> otherwise.
            </returns>
            <exception cref="!:ArgumentException">
              When the supplied name does not identify an attribute.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.Ext.IAttributes2.IsDeclared(System.String,System.String)" -->
        <member name="M:Sax.Net.Ext.IAttributes2.IsSpecified(System.Int32)">
            <summary>
              Returns true unless the attribute value was provided
              by DTD defaulting.
            </summary>
            <param name="index">
              The attribute index (zero-based).
            </param>
            <returns>
              <c>true</c> if the value was found in the XML text,
              <c>false</c> if the value was provided by DTD defaulting.
            </returns>
            <exception cref="!:IndexOutOfRangeException">
              When the supplied index does not identify an attribute.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.Ext.IAttributes2.IsSpecified(System.String,System.String)" -->
        <member name="M:Sax.Net.Ext.IAttributes2.IsSpecified(System.String)">
            <summary>
              Returns true unless the attribute value was provided
              by DTD defaulting.
            </summary>
            <param name="qName">
              The XML qualified (prefixed) name.
            </param>
            <returns>
              <c>true</c> if the value was found in the XML text,
              <c>false</c> if the value was provided by DTD defaulting.
            </returns>
            <exception cref="!:ArgumentException">
              When the supplied name does not identify an attribute.
            </exception>
        </member>
        <member name="T:Sax.Net.Ext.IDeclHandler">
            <summary>
              SAX2 extension handler for DTD declaration events.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                This is an optional extension handler for SAX2 to provide more
                complete information about DTD declarations in an XML document.
                XML readers are not required to recognize this handler, and it
                is not part of core-only SAX2 distributions.
              </para>
              <para>
                Note that data-related DTD declarations (unparsed entities and
                notations) are already reported through the <see cref="T:Sax.Net.IDTDHandler" /> interface.
              </para>
              <para>
                If you are using the declaration handler together with a lexical
                handler, all of the events will occur between the
                <see cref="M:Sax.Net.Ext.ILexicalHandler.StartDTD(System.String,System.String,System.String)" /> and the
                <see cref="M:Sax.Net.Ext.ILexicalHandler.EndDTD" /> events.
              </para>
              <para>
                To set the DeclHandler for an XML reader, use the
                <see cref="M:Sax.Net.IXmlReader.SetProperty(System.String,System.Object)" /> method
                with the property name
                <c>http://xml.org/sax/properties/declaration-handler</c>
                and an object implementing this interface (or null) as the value.
                If the reader does not report declaration events, it will throw a
                <see cref="T:Sax.Net.SAXNotRecognizedException" />
                when you attempt to register the handler.
              </para>
            </summary>
        </member>
        <member name="M:Sax.Net.Ext.IDeclHandler.ElementDecl(System.String,System.String)">
            <summary>
              Report an element type declaration.
              <para>
                The content model will consist of the string "EMPTY", the
                string "ANY", or a parenthesised group, optionally followed
                by an occurrence indicator.  The model will be normalized so
                that all parameter entities are fully resolved and all whitespace
                is removed,and will include the enclosing parentheses.  Other
                normalization (such as removing redundant parentheses or
                simplifying occurrence indicators) is at the discretion of the
                parser.
              </para>
            </summary>
            <param name="name">
              The element type name.
            </param>
            <param name="model">
              The content model as a normalized string.
            </param>
            <exception cref="T:Sax.Net.SAXException">
              The application may raise an exception.
            </exception>
        </member>
        <member name="M:Sax.Net.Ext.IDeclHandler.AttributeDecl(System.String,System.String,System.String,System.String,System.String)">
            <summary>
              Report an attribute type declaration.
              <para>
                Only the effective (first) declaration for an attribute will
                be reported.  The type will be one of the strings "CDATA",
                "ID", "IDREF", "IDREFS", "NMTOKEN", "NMTOKENS", "ENTITY",
                "ENTITIES", a parenthesized token group with
                the separator "|" and all whitespace removed, or the word
                "NOTATION" followed by a space followed by a parenthesized
                token group with all whitespace removed.
              </para>
              <para>
                The value will be the value as reported to applications,
                appropriately normalized and with entity and character
                references expanded.
              </para>
            </summary>
            <param name="eName">
              The name of the associated element.
            </param>
            <param name="aName">
              The name of the attribute.
            </param>
            <param name="type">
              A string representing the attribute type.
            </param>
            <param name="mode">
              A string representing the attribute defaulting mode
              ("#IMPLIED", "#REQUIRED", or "#FIXED") or null if
              none of these applies.
            </param>
            <param name="value">
              A string representing the attribute's default value,
              or null if there is none.
            </param>
            <exception cref="T:Sax.Net.SAXException">
              The application may raise an exception.
            </exception>
        </member>
        <member name="M:Sax.Net.Ext.IDeclHandler.InternalEntityDecl(System.String,System.String)">
            <summary>
              Report an internal entity declaration.
              <para>
                Only the effective (first) declaration for each entity
                will be reported.  All parameter entities in the value
                will be expanded, but general entities will not.
              </para>
            </summary>
            <param name="name">
              The name of the entity.  If it is a parameter
              entity, the name will begin with '%'.
            </param>
            <param name="value">
              The replacement text of the entity.
            </param>
            <exception cref="T:Sax.Net.SAXException">
              The application may raise an exception.
            </exception>
            <seealso cref="M:Sax.Net.Ext.IDeclHandler.ExternalEntityDecl(System.String,System.String,System.String)" />
            <seealso cref="M:Sax.Net.IDTDHandler.UnparsedEntityDecl(System.String,System.String,System.String,System.String)" />
        </member>
        <member name="M:Sax.Net.Ext.IDeclHandler.ExternalEntityDecl(System.String,System.String,System.String)">
            <summary>
              Report a parsed external entity declaration.
              <para>
                Only the effective (first) declaration for each entity
                will be reported.
              </para>
              <para>
                If the system identifier is a URL, the parser must resolve it
                fully before passing it to the application.
              </para>
            </summary>
            <param name="name">
              The name of the entity.  If it is a parameter
              entity, the name will begin with '%'.
            </param>
            <param name="publicId">
              The entity's public identifier, or null if none
              was given.
            </param>
            <param name="systemId">
              The entity's system identifier.
            </param>
            <exception cref="T:Sax.Net.SAXException">
              The application may raise an exception.
            </exception>
            <seealso cref="M:Sax.Net.Ext.IDeclHandler.InternalEntityDecl(System.String,System.String)" />
            <seealso cref="M:Sax.Net.IDTDHandler.UnparsedEntityDecl(System.String,System.String,System.String,System.String)" />
        </member>
        <member name="T:Sax.Net.Ext.IEntityResolver2">
            <summary>
              Extended interface for mapping external entity references to input
              sources, or providing a missing external subset.  The
              <see cref="P:Sax.Net.IXmlReader.EntityResolver" /> property
              is used to provide implementations of this interface to parsers.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
              </blockquote>
              <para>
                If a SAX application requires the customized handling which this
                interface defines for external entities, it must ensure that it uses
                an XMLReader with the
                <em>http://xml.org/sax/features/use-entity-resolver2</em> feature flag
                set to <em>true</em> (which is its default value when the feature is
                recognized).  If that flag is unrecognized, or its value is false,
                or the resolver does not implement this interface, then only the
                <see cref="T:Sax.Net.IEntityResolver" /> method will be used.
              </para>
              <para>
                That supports three categories of application that modify entity
                resolution.  <em>Old Style</em> applications won't know about this interface;
                they will provide an EntityResolver.
                <em>Transitional Mode</em> provide an EntityResolver2 and automatically
                get the benefit of its methods in any systems (parsers or other tools)
                supporting it, due to polymorphism.
                Both <em>Old Style</em> and <em>Transitional Mode</em> applications will
                work with any SAX2 parser.
                <em>New style</em> applications will fail to run except on SAX2 parsers
                that support this particular feature.
                They will insist that feature flag have a value of "true", and the
                EntityResolver2 implementation they provide  might throw an exception
                if the original SAX 1.0 style entity resolution method is invoked.
              </para>
            </summary>
            <seealso cref="P:Sax.Net.IXmlReader.EntityResolver" />
        </member>
        <member name="M:Sax.Net.Ext.IEntityResolver2.GetExternalSubset(System.String,System.String)">
            <summary>
              Allows applications to provide an external subset for documents
              that don't explicitly define one.  Documents with DOCTYPE declarations
              that omit an external subset can thus augment the declarations
              available for validation, entity processing, and attribute processing
              (normalization, defaulting, and reporting types including ID).
              This augmentation is reported
              through the <see cref="M:Sax.Net.Ext.ILexicalHandler.StartDTD(System.String,System.String,System.String)" /> method as if
              the document text had originally included the external subset;
              this callback is made before any internal subset data or errors
              are reported.
              <para>
                This method can also be used with documents that have no DOCTYPE
                declaration.  When the root element is encountered,
                but no DOCTYPE declaration has been seen, this method is
                invoked.  If it returns a value for the external subset, that root
                element is declared to be the root element, giving the effect of
                splicing a DOCTYPE declaration at the end the prolog of a document
                that could not otherwise be valid.  The sequence of parser callbacks
                in that case logically resembles this:
              </para>
              <code>
                ... comments and PIs from the prolog (as usual)
                StartDTD ("rootName", source.PublicId, source.SystemId);
                StartEntity ("[dtd]");
                ... declarations, comments, and PIs from the external subset
                EndEntity ("[dtd]");
                EndDTD ();
                ... then the rest of the document (as usual)
                StartElement (..., "rootName", ...);
              </code>
              <para>
                Note that the InputSource gets no further resolution.
                Implementations of this method may wish to invoke
                <see cref="M:Sax.Net.Ext.IEntityResolver2.ResolveEntity(System.String,System.String,System.String,System.String)" /> to gain benefits such as use
                of local caches of DTD entities.  Also, this method will never be
                used by a (non-validating) processor that is not including external
                parameter entities.
              </para>
              <para>
                Uses for this method include facilitating data validation when
                interoperating with XML processors that would always require
                undesirable network accesses for external entities, or which for
                other reasons adopt a "no DTDs" policy.
                Non-validation motives include forcing documents to include DTDs so
                that attributes are handled consistently.
                For example, an XPath processor needs to know which attibutes have
                type "ID" before it can process a widely used type of reference.
              </para>
              <para>
                <strong>Warning:</strong> Returning an external subset modifies
                the input document.  By providing definitions for general entities,
                it can make a malformed document appear to be well formed.
              </para>
            </summary>
            <param name="name">
              Identifies the document root element.  This name comes
              from a DOCTYPE declaration (where available) or from the actual
              root element.
            </param>
            <param name="baseUri">
              The document's base URI, serving as an additional
              hint for selecting the external subset.  This is always an absolute
              URI, unless it is null because the XMLReader was given an InputSource
              without one.
            </param>
            <returns>
              An InputSource object describing the new external subset
              to be used by the parser, or null to indicate that no external
              subset is provided.
            </returns>
            <exception cref="T:Sax.Net.SAXException">
              Any SAX exception, possibly wrapping
              another exception.
            </exception>
            <exception cref="!:IOException">
              Probably indicating a failure to create
              a new InputStream or Reader, or an illegal URL.
            </exception>
        </member>
        <member name="M:Sax.Net.Ext.IEntityResolver2.ResolveEntity(System.String,System.String,System.String,System.String)">
            <summary>
              Allows applications to map references to external entities into input
              sources, or tell the parser it should use conventional URI resolution.
              This method is only called for external entities which have been
              properly declared.
              This method provides more flexibility than the <see cref="T:Sax.Net.IEntityResolver" />
              interface, supporting implementations of more complex catalogue
              schemes such as the one defined by the
              <a href="http://www.oasis-open.org/committees/entity/spec-2001-08-06.html">OASIS XML Catalogs</a> specification.
              <para>
                Parsers configured to use this resolver method will call it
                to determine the input source to use for any external entity
                being included because of a reference in the XML text.
                That excludes the document entity, and any external entity returned
                by <see cref="M:Sax.Net.Ext.IEntityResolver2.GetExternalSubset(System.String,System.String)" />.
                When a (non-validating) processor is configured not to include
                a class of entities (parameter or general) through use of feature
                flags, this method is not invoked for such entities.
              </para>
              <para>
                Note that the entity naming scheme used here is the same one
                used in the <see cref="T:Sax.Net.Ext.ILexicalHandler" />, or in the {@link
                org.xml.sax.ContentHandler#skippedEntity
                ContentHandler.skippedEntity()}
                method.
              </para>
            </summary>
            <param name="name">
              Identifies the external entity being resolved.
              Either "[dtd]" for the external subset, or a name starting
              with "%" to indicate a parameter entity, or else the name of
              a general entity.  This is never null when invoked by a SAX2
              parser.
            </param>
            <param name="publicId">
              The public identifier of the external entity being
              referenced (normalized as required by the XML specification), or
              null if none was supplied.
            </param>
            <param name="baseUri">
              The URI with respect to which relative systemIDs
              are interpreted.  This is always an absolute URI, unless it is
              null (likely because the XMLReader was given an InputSource without
              one).  This URI is defined by the XML specification to be the one
              associated with the "&lt;" starting the relevant declaration.
            </param>
            <param name="systemId">
              The system identifier of the external entity
              being referenced; either a relative or absolute URI.
              This is never null when invoked by a SAX2 parser; only declared
              entities, and any external subset, are resolved by such parsers.
            </param>
            <returns>
              An InputSource object describing the new input source to
              be used by the parser.  Returning null directs the parser to
              resolve the system ID against the base URI and open a connection
              to resulting URI.
            </returns>
            <exception cref="T:Sax.Net.SAXException">
              Any SAX exception, possibly wrapping
              another exception.
            </exception>
            <exception cref="!:IOException">
              Probably indicating a failure to create
              a new InputStream or Reader, or an illegal URL.
            </exception>
        </member>
        <member name="T:Sax.Net.Ext.ILexicalHandler">
            <summary>
              SAX2 extension handler for lexical events.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                This is an optional extension handler for SAX2 to provide
                lexical information about an XML document, such as comments
                and CDATA section boundaries.
                XML readers are not required to recognize this handler, and it
                is not part of core-only SAX2 distributions.
              </para>
              <para>
                The events in the lexical handler apply to the entire document,
                not just to the document element, and all lexical handler events
                must appear between the content handler's startDocument and
                endDocument events.
              </para>
              <para>
                To set the LexicalHandler for an XML reader, use the
                <see cref="M:Sax.Net.IXmlReader.SetProperty(System.String,System.Object)" /> method
                with the property name
                <c>http://xml.org/sax/properties/lexical-handler</c>
                and an object implementing this interface (or null) as the value.
                If the reader does not report lexical events, it will throw a
                <see cref="T:Sax.Net.SAXNotRecognizedException" />
                when you attempt to register the handler.
              </para>
            </summary>
        </member>
        <member name="M:Sax.Net.Ext.ILexicalHandler.StartDTD(System.String,System.String,System.String)">
            <summary>
              Report the start of DTD declarations, if any.
              <para>
                This method is intended to report the beginning of the
                DOCTYPE declaration; if the document has no DOCTYPE declaration,
                this method will not be invoked.
              </para>
              <para>
                All declarations reported through
                <see cref="T:Sax.Net.IDTDHandler" /> or
                <see cref="T:Sax.Net.Ext.IDeclHandler" /> events must appear
                between the startDTD and <see cref="M:Sax.Net.Ext.ILexicalHandler.EndDTD" /> events.
                Declarations are assumed to belong to the internal DTD subset
                unless they appear between <see cref="M:Sax.Net.Ext.ILexicalHandler.StartEntity(System.String)" />
                and <see cref="M:Sax.Net.Ext.ILexicalHandler.EndEntity(System.String)" /> events.  Comments and
                processing instructions from the DTD should also be reported
                between the startDTD and endDTD events, in their original
                order of (logical) occurrence; they are not required to
                appear in their correct locations relative to DTDHandler
                or DeclHandler events, however.
              </para>
              <para>
                Note that the start/endDTD events will appear within
                the start/endDocument events from ContentHandler and
                before the first
                <see cref="M:Sax.Net.IContentHandler.StartElement(System.String,System.String,System.String,Sax.Net.IAttributes)" />
                event.
              </para>
            </summary>
            <param name="name">
              The document type name.
            </param>
            <param name="publicId">
              The declared public identifier for the
              external DTD subset, or null if none was declared.
            </param>
            <param name="systemId">
              The declared system identifier for the
              external DTD subset, or null if none was declared.
              (Note that this is not resolved against the document
              base URI.)
            </param>
            <exception cref="T:Sax.Net.SAXException">
              The application may raise an
              exception.
            </exception>
            <seealso cref="M:Sax.Net.Ext.ILexicalHandler.EndDTD" />
            <seealso cref="M:Sax.Net.Ext.ILexicalHandler.StartEntity(System.String)" />
        </member>
        <member name="M:Sax.Net.Ext.ILexicalHandler.EndDTD">
            <summary>
              Report the end of DTD declarations.
              <para>
                This method is intended to report the end of the
                DOCTYPE declaration; if the document has no DOCTYPE declaration,
                this method will not be invoked.
              </para>
            </summary>
            <exception cref="T:Sax.Net.SAXException">
              The application may raise an exception.
            </exception>
            <seealso cref="M:Sax.Net.Ext.ILexicalHandler.StartDTD(System.String,System.String,System.String)" />
        </member>
        <member name="M:Sax.Net.Ext.ILexicalHandler.StartEntity(System.String)">
            <summary>
              Report the beginning of some internal and external XML entities.
              <para>
                The reporting of parameter entities (including
                the external DTD subset) is optional, and SAX2 drivers that
                report LexicalHandler events may not implement it; you can use the
                <c>http://xml.org/sax/features/lexical-handler/parameter-entities</c>
                feature to query or control the reporting of parameter entities.
              </para>
              <para>
                General entities are reported with their regular names,
                parameter entities have '%' prepended to their names, and
                the external DTD subset has the pseudo-entity name "[dtd]".
              </para>
              <para>
                When a SAX2 driver is providing these events, all other
                events must be properly nested within start/end entity
                events.  There is no additional requirement that events from
                <see cref="T:Sax.Net.Ext.IDeclHandler" /> or
                <see cref="T:Sax.Net.IDTDHandler" /> be properly ordered.
              </para>
              <para>
                Note that skipped entities will be reported through the
                <see cref="M:Sax.Net.IContentHandler.SkippedEntity(System.String)" />
                event, which is part of the ContentHandler interface.
              </para>
              <para>
                Because of the streaming event model that SAX uses, some
                entity boundaries cannot be reported under any
                circumstances:
              </para>
              <ul>
                <li>general entities within attribute values</li>
                <li>parameter entities within declarations</li>
              </ul>
              <para>
                These will be silently expanded, with no indication of where
                the original entity boundaries were.
              </para>
              <para>
                Note also that the boundaries of character references (which
                are not really entities anyway) are not reported.
              </para>
              <para>All start/endEntity events must be properly nested.</para>
            </summary>
            <param name="name">
              The name of the entity.  If it is a parameter
              entity, the name will begin with '%', and if it is the
              external DTD subset, it will be "[dtd]".
            </param>
            <exception cref="T:Sax.Net.SAXException">
              The application may raise an exception.
            </exception>
            <seealso cref="M:Sax.Net.Ext.ILexicalHandler.EndEntity(System.String)" />
            <seealso cref="M:Sax.Net.Ext.IDeclHandler.InternalEntityDecl(System.String,System.String)" />
            <seealso cref="M:Sax.Net.Ext.IDeclHandler.ExternalEntityDecl(System.String,System.String,System.String)" />
        </member>
        <member name="M:Sax.Net.Ext.ILexicalHandler.EndEntity(System.String)">
            <summary>
              Report the end of an entity.
            </summary>
            <param name="name">
              The name of the entity that is ending.
            </param>
            <exception cref="T:Sax.Net.SAXException">
              The application may raise an exception.
            </exception>
            <seealso cref="M:Sax.Net.Ext.ILexicalHandler.StartEntity(System.String)" />
        </member>
        <member name="M:Sax.Net.Ext.ILexicalHandler.StartCDATA">
            <summary>
              Report the start of a CDATA section.
              <para>
                The contents of the CDATA section will be reported through
                the regular <see cref="M:Sax.Net.IContentHandler.Characters(System.Char[],System.Int32,System.Int32)" /> event;
                this event is intended only to report the boundary.
              </para>
            </summary>
            <exception cref="T:Sax.Net.SAXException">
              The application may raise an exception.
            </exception>
            <seealso cref="M:Sax.Net.Ext.ILexicalHandler.EndCDATA" />
        </member>
        <member name="M:Sax.Net.Ext.ILexicalHandler.EndCDATA">
            <summary>
              Report the end of a CDATA section.
            </summary>
            <exception cref="T:Sax.Net.SAXException">
              The application may raise an exception.
            </exception>
            <seealso cref="M:Sax.Net.Ext.ILexicalHandler.StartCDATA" />
        </member>
        <member name="M:Sax.Net.Ext.ILexicalHandler.Comment(System.Char[],System.Int32,System.Int32)">
            <summary>
              Report an XML comment anywhere in the document.
              <para>
                This callback will be used for comments inside or outside the
                document element, including comments in the external DTD
                subset (if read).  Comments in the DTD must be properly
                nested inside start/endDTD and start/endEntity events (if
                used).
              </para>
            </summary>
            <param name="ch">
              An array holding the characters in the comment.
            </param>
            <param name="start">
              The starting position in the array.
            </param>
            <param name="length">
              The number of characters to use from the array.
            </param>
            <exception cref="T:Sax.Net.SAXException">
              The application may raise an exception.
            </exception>
        </member>
        <member name="T:Sax.Net.Ext.ILocator2">
            <summary>
              SAX2 extension to augment the entity information provided
              though a <see cref="T:Sax.Net.ILocator" />.
              If an implementation supports this extension, the Locator
              provided in <see cref="M:Sax.Net.IContentHandler.SetDocumentLocator(Sax.Net.ILocator)" /> will implement this
              interface, and the
              <em>http://xml.org/sax/features/use-locator2</em> feature
              flag will have the value <em>true</em>.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
              </blockquote>
              <para>
                XMLReader implementations are not required to support this
                information, and it is not part of core-only SAX2 distributions.
              </para>
            </summary>
        </member>
        <member name="P:Sax.Net.Ext.ILocator2.XmlVersion">
            <summary>
              Returns the version of XML used for the entity.  This will
              normally be the identifier from the current entity's
              <em>&lt;?xml&amp;nbsp;version='...'&amp;nbsp;...?&gt;</em> declaration,
              or be defaulted by the parser.
            </summary>
            <returns>
              Identifier for the XML version being used to interpret
              the entity's text, or null if that information is not yet
              available in the current parsing state.
            </returns>
        </member>
        <member name="P:Sax.Net.Ext.ILocator2.Encoding">
            <summary>
              Returns the name of the character encoding for the entity.
              If the encoding was declared externally (for example, in a MIME
              Content-Type header), that will be the name returned.  Else if there
              was an <em>&lt;?xml&amp;nbsp;...encoding='...'?&gt;</em> declaration at
              the start of the document, that encoding name will be returned.
              Otherwise the encoding will been inferred (normally to be UTF-8, or
              some UTF-16 variant), and that inferred name will be returned.
              <para>
                When an <see cref="T:Sax.Net.InputSource" /> is used
                to provide an entity's character stream, this method returns the
                encoding provided in that input stream.
              </para>
              <para>
                Note that some recent W3C specifications require that text
                in some encodings be normalized, using Unicode Normalization
                Form C, before processing.  Such normalization must be performed
                by applications, and would normally be triggered based on the
                value returned by this method.
              </para>
              <para>
                Encoding names may be those used by the underlying JVM,
                and comparisons should be case-insensitive.
              </para>
            </summary>
            <returns>
              Name of the character encoding being used to interpret
              * the entity's text, or null if this was not provided for a *
              character stream passed through an InputSource or is otherwise
              not yet available in the current parsing state.
            </returns>
        </member>
        <member name="T:Sax.Net.Ext.Locator2">
            <summary>
              SAX2 extension helper for holding additional Entity information,
              implementing the <see cref="T:Sax.Net.Ext.ILocator2" /> interface.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
              </blockquote>
              <para> This is not part of core-only SAX2 distributions.</para>
            </summary>
        </member>
        <member name="M:Sax.Net.Ext.Locator2.#ctor">
            <summary>
              Construct a new, empty Locator2 object.
              This will not normally be useful, since the main purpose
              of this class is to make a snapshot of an existing Locator.
            </summary>
        </member>
        <member name="M:Sax.Net.Ext.Locator2.#ctor(Sax.Net.ILocator)">
            <summary>
              Copy an existing Locator or Locator2 object.
              If the object implements Locator2, values of the
              <em>encoding</em> and <em>version</em>strings are copied,
              otherwise they set to <em>null</em>.
            </summary>
            <param name="locator">
              The existing Locator object.
            </param>
        </member>
        <member name="T:Sax.Net.Helpers.Attributes">
            <summary>
              Default implementation of the Attributes interface.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                This class provides a default implementation of the SAX2
                <see cref="T:Sax.Net.IAttributes" /> interface, with the
                addition of manipulators so that the list can be modified or
                reused.
              </para>
              <para>There are two typical uses of this class:</para>
              <ol>
                <li>
                  to take a persistent snapshot of an Attributes object
                  in a <see cref="M:Sax.Net.IContentHandler.StartElement(System.String,System.String,System.String,Sax.Net.IAttributes)" /> event; or
                </li>
                <li>to construct or modify an Attributes object in a SAX2 driver or filter.</li>
              </ol>
            </summary>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.#ctor">
            <summary>
              Construct a new, empty Attributes object.
            </summary>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.#ctor(Sax.Net.IAttributes)">
            <summary>
              Copy an existing <see cref="T:Sax.Net.IAttributes" /> object.
              <para></para>
              This constructor is especially useful inside a
              <see cref="M:Sax.Net.IContentHandler.StartElement(System.String,System.String,System.String,Sax.Net.IAttributes)" /> event.
            </summary>
            <param name="atts">
              The existing IAttributes object.
            </param>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.Clear">
            <summary>
              Clear the attribute list for reuse.
              <para>
                Note that little memory is freed by this call:
                the current array is kept so it can be
                reused.
              </para>
            </summary>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.SetAttributes(Sax.Net.IAttributes)">
            <summary>
              Copy an entire Attributes object.
              <para>
                It may be more efficient to reuse an existing object
                rather than constantly allocating new ones.
              </para>
            </summary>
            <param name="atts">The attributes to copy.</param>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.AddAttribute(System.String,System.String,System.String,System.String,System.String)">
            <summary>
              Add an attribute to the end of the list.
              <para>
                For the sake of speed, this method does no checking
                to see if the attribute is already in the list: that is
                the responsibility of the application.
              </para>
            </summary>
            <param name="uri">
              The Namespace URI, or the empty string if
              none is available or Namespace processing is not
              being performed.
            </param>
            <param name="localName">
              The local name, or the empty string if
              Namespace processing is not being performed.
            </param>
            <param name="qName">
              The qualified (prefixed) name, or the empty string
              if qualified names are not available.
            </param>
            <param name="type">The attribute type as a string.</param>
            <param name="value">The attribute value.</param>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.SetAttribute(System.Int32,System.String,System.String,System.String,System.String,System.String)">
            <summary>
              Set an attribute in the list.
              <para>
                For the sake of speed, this method does no checking
                for name conflicts or well-formedness: such checks are the
                responsibility of the application.
              </para>
            </summary>
            <param name="index">The index of the attribute (zero-based).</param>
            <param name="uri">
              The Namespace URI, or the empty string if
              none is available or Namespace processing is not
              being performed.
            </param>
            <param name="localName">
              The local name, or the empty string if
              Namespace processing is not being performed.
            </param>
            <param name="qName">
              The qualified (prefixed) name, or the empty string
              if qualified names are not available.
            </param>
            <param name="type">The attribute type as a string.</param>
            <param name="value">The attribute value.</param>
            <exception cref="T:System.IndexOutOfRangeException">
              When the supplied index does not point to an attribute in the list.
            </exception>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.RemoveAttribute(System.Int32)">
            <summary>
              Remove an attribute from the list.
            </summary>
            <param name="index">The index of the attribute (zero-based).</param>
            <exception cref="T:System.IndexOutOfRangeException">
              When the supplied index does not point to an attribute in the list.
            </exception>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.SetUri(System.Int32,System.String)">
            <summary>
              Set the Namespace URI of a specific attribute.
            </summary>
            <param name="index">The index of the attribute (zero-based).</param>
            <param name="uri">
              The attribute's Namespace URI, or the empty
              string for none.
            </param>
            <exception cref="T:System.IndexOutOfRangeException">
              When the supplied index does not point to an attribute in the list.
            </exception>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.SetLocalName(System.Int32,System.String)">
            <summary>
              Set the local name of a specific attribute.
            </summary>
            <param name="index">The index of the attribute (zero-based).</param>
            <param name="localName">
              The attribute's local name, or the empty
              string for none.
            </param>
            <exception cref="T:System.IndexOutOfRangeException">
              When the supplied index does not point to an attribute in the list.
            </exception>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.SetQName(System.Int32,System.String)">
            <summary>
              Set the qualified name of a specific attribute.
            </summary>
            <param name="index">The index of the attribute (zero-based).</param>
            <param name="qName">
              The attribute's qualified name, or the empty
              string for none.
            </param>
            <exception cref="T:System.IndexOutOfRangeException">
              When the supplied index does not point to an attribute in the list.
            </exception>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.SetType(System.Int32,System.String)">
            <summary>
              Set the type of a specific attribute.
            </summary>
            <param name="index">The index of the attribute (zero-based).</param>
            <param name="type">The attribute's type.</param>
            <exception cref="T:System.IndexOutOfRangeException">
              When the supplied index does not point to an attribute in the list.
            </exception>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.SetValue(System.Int32,System.String)">
            <summary>
              Set the value of a specific attribute.
            </summary>
            <param name="index">The index of the attribute (zero-based).</param>
            <param name="value">The attribute's value.</param>
            <exception cref="T:System.IndexOutOfRangeException">
              When the supplied index does not point to an attribute in the list.
            </exception>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.EnsureCapacity(System.Int32)">
            <summary>
              Ensure the internal array's capacity.
            </summary>
            <param name="n">
              The minimum number of attributes that the array must
              be able to hold.
            </param>
        </member>
        <member name="M:Sax.Net.Helpers.Attributes.BadIndex(System.Int32)">
            <summary>
              Report a bad array index in a manipulator.
            </summary>
            <param name="index">The index to report.</param>
            <exception cref="T:System.IndexOutOfRangeException">Always.</exception>
        </member>
        <member name="T:Sax.Net.Helpers.BaseXmlReaderFactory">
            <summary>
                XmlReaderFactory base class
            </summary>
        </member>
        <member name="M:Sax.Net.Helpers.BaseXmlReaderFactory.CreateXmlReader">
            <summary>
                Attempt to create an XMLReader from system defaults.
            </summary>
            <returns>
                A new XMLReader.
            </returns>
            <exception cref="T:Sax.Net.SAXException">
                If no default XMLReader class
                can be identified and instantiated.
            </exception>
            <seealso cref="M:Sax.Net.Helpers.BaseXmlReaderFactory.CreateXmlReader(System.String)" />
        </member>
        <member name="M:Sax.Net.Helpers.BaseXmlReaderFactory.CreateXmlReader(System.String)">
            <summary>
                Attempt to create an XML reader from a type name.
                <para>
                    Given a type name, this method attempts to load
                    and instantiate the class as an XML reader.
                </para>
                <para>
                    Note that this method will not be usable in environments where
                    the caller is not permitted to load types dynamically.
                </para>
            </summary>
            <returns>
                A new XML reader.
            </returns>
            <exception cref="T:Sax.Net.SAXException">
                If the type cannot be loaded, instantiated, and cast to IXmlReader.
            </exception>
            <seealso cref="M:Sax.Net.Helpers.BaseXmlReaderFactory.CreateXmlReader" />
        </member>
        <member name="M:Sax.Net.Helpers.BaseXmlReaderFactory.CreateXmlReader(System.Type)">
            <summary>
                Creates a new <see cref="T:Sax.Net.IXmlReader" /> based on the type passed in.
            </summary>
            <param name="type">The type</param>
            <returns>A new XML reader.</returns>
            <exception cref="T:Sax.Net.SAXException">If the type cannot be loaded, instantiated, and cast to IXmlReader.</exception>
        </member>
        <member name="T:Sax.Net.Helpers.DefaultHandler">
            <summary>
              Default base class for SAX2 event handlers.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                This class is available as a convenience base class for SAX2
                applications: it provides default implementations for all of the
                callbacks in the four core SAX2 handler classes:
              </para>
              <ul>
                <li>
                  <see cref="T:Sax.Net.IEntityResolver" />
                </li>
                <li>
                  <see cref="T:Sax.Net.IDTDHandler" />
                </li>
                <li>
                  <see cref="T:Sax.Net.IContentHandler" />
                </li>
                <li>
                  <see cref="T:Sax.Net.IErrorHandler" />
                </li>
              </ul>
              <para>
                Application writers can extend this class when they need to
                implement only part of an interface; parser writers can
                instantiate this class to provide default handlers when the
                application has not supplied its own.
              </para>
            </summary>
            <seealso cref="T:Sax.Net.IEntityResolver" />
            <seealso cref="T:Sax.Net.IDTDHandler" />
            <seealso cref="T:Sax.Net.IContentHandler" />
            <seealso cref="T:Sax.Net.IErrorHandler" />
        </member>
        <member name="T:Sax.Net.Helpers.IXmlReaderFactory">
            <summary> Factory for creating an XML reader.</summary>
        </member>
        <member name="M:Sax.Net.Helpers.IXmlReaderFactory.CreateXmlReader">
            <summary>
                Attempt to create an XMLReader from system defaults.
            </summary>
            <returns>
                A new XMLReader.
            </returns>
            <exception cref="T:Sax.Net.SAXException">
                If no default XMLReader class
                can be identified and instantiated.
            </exception>
            <seealso cref="M:Sax.Net.Helpers.IXmlReaderFactory.CreateXmlReader(System.String)" />
        </member>
        <member name="M:Sax.Net.Helpers.IXmlReaderFactory.CreateXmlReader(System.String)">
            <summary>
                Attempt to create an XML reader from a type name.
                <para>
                    Given a type name, this method attempts to load
                    and instantiate the class as an XML reader.
                </para>
                <para>
                    Note that this method will not be usable in environments where
                    the caller is not permitted to load types dynamically.
                </para>
            </summary>
            <returns>
                A new XML reader.
            </returns>
            <exception cref="T:Sax.Net.SAXException">
                If the type cannot be loaded, instantiated, and cast to IXmlReader.
            </exception>
            <seealso cref="M:Sax.Net.Helpers.IXmlReaderFactory.CreateXmlReader" />
        </member>
        <member name="T:Sax.Net.Helpers.Locator">
            <summary>
              Provide an optional convenience implementation of Locator.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                This class is available mainly for application writers, who
                can use it to make a persistent snapshot of a locator at any
                point during a document parse:
              </para>
              <code>
                ILocator locator;
                ILocator startloc;
                public void setLocator (ILocator locator)
                {
                  this.locator = locator;
                }
                public void StartDocument ()
                {
                  ILocator startloc = new Locator(locator);
                }
              </code>
              <para>
                Normally, parser writers will not use this class, since it
                is more efficient to provide location information only when
                requested, rather than constantly updating a Locator object.
              </para>
            </summary>
            <seealso cref="T:Sax.Net.ILocator" />
        </member>
        <member name="M:Sax.Net.Helpers.Locator.#ctor">
            <summary>
              Zero-argument constructor.
              <para>
                This will not normally be useful, since the main purpose
                of this class is to make a snapshot of an existing Locator.
              </para>
            </summary>
        </member>
        <member name="M:Sax.Net.Helpers.Locator.#ctor(Sax.Net.ILocator)">
            <summary>
              Copy constructor.
              <para>
                Create a persistent copy of the current state of a locator.
                When the original locator changes, this copy will still keep
                the original values (and it can be used outside the scope of
                DocumentHandler methods).
              </para>
            </summary>
            <param name="locator">The locator to copy.</param>
        </member>
        <member name="T:Sax.Net.Helpers.NamespaceSupport">
            <summary>
              Encapsulate Namespace logic for use by applications using SAX,
              or internally by SAX drivers.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                This class encapsulates the logic of Namespace processing: it
                tracks the declarations currently in force for each context and
                automatically processes qualified XML names into their Namespace
                parts; it can also be used in reverse for generating XML qnames
                from Namespaces.
              </para>
              <para>
                Namespace support objects are reusable, but the reset method
                must be invoked between each session.
              </para>
              <para>Here is a simple session:</para>
              <code>
                string parts[] = new string[3];
                NamespaceSupport support = new NamespaceSupport();
                support.PushContext();
                support.DeclarePrefix("", "http://www.w3.org/1999/xhtml");
                support.DeclarePrefix("dc", "http://www.purl.org/dc#");
                parts = support.ProcessName("p", parts, false);
                Console.WriteLine("Namespace URI: " + parts[0]);
                Console.WriteLine("Local name: " + parts[1]);
                Console.WriteLine("Raw name: " + parts[2]);
                parts = support.ProcessName("dc:title", parts, false);
                Console.WriteLine("Namespace URI: " + parts[0]);
                Console.WriteLine("Local name: " + parts[1]);
                Console.WriteLine("Raw name: " + parts[2]);
                support.PopContext();
              </code>
              <para>
                Note that this class is optimized for the use case where most
                elements do not contain Namespace declarations: if the same
                prefix/URI mapping is repeated for each context (for example), this
                class will be somewhat less efficient.
              </para>
              <para>
                Although SAX drivers (parsers) may choose to use this class to
                implement namespace handling, they are not required to do so.
                Applications must track namespace information themselves if they
                want to use namespace information.
              </para>
            </summary>
        </member>
        <member name="F:Sax.Net.Helpers.NamespaceSupport.XMLNS">
            <summary>
              The XML Namespace URI as a constant.
              The value is <c>http://www.w3.org/XML/1998/namespace</c>
              as defined in the "Namespaces in XML" * recommendation.
              <para>This is the Namespace URI that is automatically mapped to the "xml" prefix.</para>
            </summary>
        </member>
        <member name="F:Sax.Net.Helpers.NamespaceSupport.NSDECL">
            <summary>
              The namespace declaration URI as a constant.
              The value is <c>http://www.w3.org/xmlns/2000/</c>, as defined
              in a backwards-incompatible erratum to the "Namespaces in XML"
              recommendation.  Because that erratum postdated SAX2, SAX2 defaults
              to the original recommendation, and does not normally use this URI.
              <para>
                This is the Namespace URI that is optionally applied to
                <em>xmlns</em> and <em>xmlns:*</em> attributes, which are used to
                declare namespaces.
              </para>
            </summary>
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.SetNamespaceDeclUris(System.Boolean)" />
            <seealso cref="P:Sax.Net.Helpers.NamespaceSupport.IsNamespaceDeclUris" />
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.#ctor">
            <summary>
              Create a new Namespace support object.
            </summary>
        </member>
        <member name="P:Sax.Net.Helpers.NamespaceSupport.IsNamespaceDeclUris">
            <summary>
              Returns true if namespace declaration attributes are placed into
              a namespace.  This behavior is not the default.
            </summary>
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.Reset">
            <summary>
              Reset this Namespace support object for reuse.
              <para>
                It is necessary to invoke this method before reusing the
                Namespace support object for a new session.  If namespace
                declaration URIs are to be supported, that flag must also
                be set to a non-default value.
              </para>
            </summary>
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.SetNamespaceDeclUris(System.Boolean)" />
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.PushContext">
            <summary>
              Start a new Namespace context.
              The new context will automatically inherit
              the declarations of its parent context, but it will also keep
              track of which declarations were made within this context.
              <para>
                Event callback code should start a new context once per element.
                This means being ready to call this in either of two places.
                For elements that don't include namespace declarations, the
                <em>ContentHandler.startElement()</em> callback is the right place.
                For elements with such a declaration, it'd done in the first
                <em>ContentHandler.startPrefixMapping()</em> callback.
                A boolean flag can be used to
                track whether a context has been started yet.  When either of
                those methods is called, it checks the flag to see if a new context
                needs to be started.  If so, it starts the context and sets the
                flag.  After <em>ContentHandler.startElement()</em>
                does that, it always clears the flag.
              </para>
              <para>
                Normally, SAX drivers would push a new context at the beginning
                of each XML element.  Then they perform a first pass over the
                attributes to process all namespace declarations, making
                <em>ContentHandler.startPrefixMapping()</em> callbacks.
                Then a second pass is made, to determine the namespace-qualified
                names for all attributes and for the element name.
                Finally all the information for the
                <em>ContentHandler.startElement()</em> callback is available,
                so it can then be made.
              </para>
              <para>
                The Namespace support object always starts with a base context
                already in force: in this context, only the "xml" prefix is
                declared.
              </para>
            </summary>
            <seealso cref="T:Sax.Net.IContentHandler" />
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.PopContext" />
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.PopContext">
            <summary>
              Revert to the previous Namespace context.
              <para>
                Normally, you should pop the context at the end of each
                XML element.  After popping the context, all Namespace prefix
                mappings that were previously in force are restored.
              </para>
              <para>
                You must not attempt to declare additional Namespace
                prefixes after popping a context, unless you push another
                context first.
              </para>
            </summary>
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.PushContext" />
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.DeclarePrefix(System.String,System.String)">
            <summary>
              Declare a Namespace prefix.  All prefixes must be declared
              before they are referenced.  For example, a SAX driver (parser)
              would scan an element's attributes
              in two passes:  first for namespace declarations,
              then a second pass using <see cref="M:Sax.Net.Helpers.NamespaceSupport.ProcessName(System.String,System.String[],System.Boolean)" /> to
              interpret prefixes against (potentially redefined) prefixes.
              <para>
                This method declares a prefix in the current Namespace
                context; the prefix will remain in force until this context
                is popped, unless it is shadowed in a descendant context.
              </para>
              <para>
                To declare the default element Namespace, use the empty string as
                the prefix.
              </para>
              <para>
                Note that you must <em>not</em> declare a prefix after
                you've pushed and popped another Namespace context, or
                treated the declarations phase as complete by processing
                a prefixed name.
              </para>
              <para>
                Note that there is an asymmetry in this library: <see cref="M:Sax.Net.Helpers.NamespaceSupport.GetPrefix(System.String)" /> will not return the "" prefix,
                even if you have declared a default element namespace.
                To check for a default namespace,
                you have to look it up explicitly using <see cref="M:Sax.Net.Helpers.NamespaceSupport.GetUri(System.String)" />.
                This asymmetry exists to make it easier to look up prefixes
                for attribute names, where the default prefix is not allowed.
              </para>
            </summary>
            <param name="prefix">
              The prefix to declare, or the empty string to
              indicate the default element namespace.  This may never have
              the value "xml" or "xmlns".
            </param>
            <param name="uri">
              The Namespace URI to associate with the prefix.
            </param>
            <returns><c>true</c> if the prefix was legal, <c>false</c> otherwise</returns>
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.ProcessName(System.String,System.String[],System.Boolean)" />
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.GetUri(System.String)" />
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.GetPrefix(System.String)" />
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.ProcessName(System.String,System.String[],System.Boolean)">
            <summary>
              Process a raw XML qualified name, after all declarations in the
              current context have been handled by <see cref="M:Sax.Net.Helpers.NamespaceSupport.DeclarePrefix(System.String,System.String)" />.
              <para>
                This method processes a raw XML qualified name in the
                current context by removing the prefix and looking it up among
                the prefixes currently declared.  The return value will be the
                array supplied by the caller, filled in as follows:
              </para>
              <dl>
                <dt>parts[0]</dt>
                <dd>
                  The Namespace URI, or an empty string if none is
                  in use.
                </dd>
                <dt>parts[1]</dt>
                <dd>The local name (without prefix).</dd>
                <dt>parts[2]</dt>
                <dd>The original raw name.</dd>
              </dl>
              <para>
                All of the strings in the array will be internalized.  If
                the raw name has a prefix that has not been declared, then
                the return value will be null.
              </para>
              <para>
                Note that attribute names are processed differently than
                element names: an unprefixed element name will receive the
                default Namespace (if any), while an unprefixed attribute name
                will not.
              </para>
            </summary>
            <param name="qName">
              The XML qualified name to be processed.
            </param>
            <param name="parts">
              An array supplied by the caller, capable of
              holding at least three members.
            </param>
            <param name="isAttribute">
              A flag indicating whether this is an
              attribute name (true) or an element name (false).
            </param>
            <returns>
              The supplied array holding three internalized strings
              representing the Namespace URI (or empty string), the
              local name, and the XML qualified name; or null if there
              is an undeclared prefix.
            </returns>
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.DeclarePrefix(System.String,System.String)" />
            <seealso cref="M:System.String.Intern(System.String)" />
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.GetUri(System.String)">
            <summary>
              Look up a prefix and get the currently-mapped Namespace URI.
              <para>
                This method looks up the prefix in the current context.
                Use the empty string ("") for the default Namespace.
              </para>
            </summary>
            <param name="prefix">
              The prefix to look up.
            </param>
            <returns>
              The associated Namespace URI, or null if the prefix
              is undeclared in this context.
            </returns>
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.GetPrefix(System.String)" />
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.GetPrefixes" />
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.GetPrefixes">
            <summary>
              Return an enumeration of all prefixes whose declarations are
              active in the current context.
              This includes declarations from parent contexts that have
              not been overridden.
              <para>
                <strong>Note:</strong> if there is a default prefix, it will not be
                returned in this enumeration; check for the default prefix
                using the <see cref="M:Sax.Net.Helpers.NamespaceSupport.GetUri(System.String)" /> with an argument of "".
              </para>
            </summary>
            <returns>An enumeration of prefixes (never empty).</returns>
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.GetDeclaredPrefixes" />
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.GetUri(System.String)" />
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.GetPrefix(System.String)">
            <summary>
              Return one of the prefixes mapped to a Namespace URI.
              <para>
                If more than one prefix is currently mapped to the same
                URI, this method will make an arbitrary selection; if you
                want all of the prefixes, use the <see cref="M:Sax.Net.Helpers.NamespaceSupport.GetPrefixes" />
                method instead.
              </para>
              <para>
                <strong>Note:</strong> this will never return the empty (default) prefix;
                to check for a default prefix, use the <see cref="M:Sax.Net.Helpers.NamespaceSupport.GetUri(System.String)" />
                method with an argument of "".
              </para>
            </summary>
            <param name="uri">
              the namespace URI
            </param>
            <returns>
              one of the prefixes currently mapped to the URI supplied,
              or null if none is mapped or if the URI is assigned to
              the default namespace
            </returns>
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.GetPrefixes(System.String)" />
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.GetUri(System.String)" />
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.GetPrefixes(System.String)">
            <summary>
              Return an enumeration of all prefixes for a given URI whose
              declarations are active in the current context.
              This includes declarations from parent contexts that have
              not been overridden.
              <para>
                This method returns prefixes mapped to a specific Namespace
                URI.  The xml: prefix will be included.  If you want only one
                prefix that's mapped to the Namespace URI, and you don't care
                which one you get, use the <see cref="M:Sax.Net.Helpers.NamespaceSupport.GetPrefix(System.String)" />
                method instead.
              </para>
              <para>
                <strong>Note:</strong> the empty (default) prefix is <em>never</em> included
                in this enumeration; to check for the presence of a default
                Namespace, use the <see cref="M:Sax.Net.Helpers.NamespaceSupport.GetUri(System.String)" /> method with an
                argument of "".
              </para>
            </summary>
            <param name="uri">
              The Namespace URI.
            </param>
            <returns>An enumeration of prefixes (never empty).</returns>
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.GetPrefix(System.String)" />
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.GetDeclaredPrefixes" />
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.GetUri(System.String)" />
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.GetDeclaredPrefixes">
            <summary>
              Return an enumeration of all prefixes declared in this context.
              <para>
                The empty (default) prefix will be included in this
                enumeration; note that this behaviour differs from that of
                <see cref="M:Sax.Net.Helpers.NamespaceSupport.GetPrefix(System.String)" /> and <see cref="M:Sax.Net.Helpers.NamespaceSupport.GetPrefixes" />.
              </para>
            </summary>
            <returns>
              An enumeration of all prefixes declared in this
              context.
            </returns>
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.GetPrefixes" />
            <seealso cref="M:Sax.Net.Helpers.NamespaceSupport.GetUri(System.String)" />
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.SetNamespaceDeclUris(System.Boolean)">
            <summary>
              Controls whether namespace declaration attributes are placed
              into the <see cref="F:Sax.Net.Helpers.NamespaceSupport.NSDECL" /> namespace
              by <see cref="M:Sax.Net.Helpers.NamespaceSupport.ProcessName(System.String,System.String[],System.Boolean)" />.  This may only be
              changed before any contexts have been pushed.
            </summary>
            <exception cref="T:System.InvalidOperationException">
              when attempting to set this
              after any context has been pushed.
            </exception>
        </member>
        <member name="T:Sax.Net.Helpers.NamespaceSupport.Context">
             Internal class for a single Namespace context.
            
             <p>This module caches and reuses Namespace contexts,
             so the number allocated
             will be equal to the element depth of the document, not to the total
             number of elements (i.e. 5-10 rather than tens of thousands).
             Also, data structures used to represent contexts are shared when
             possible (child contexts without declarations) to further reduce
             the amount of memory that's consumed.
             </p>
        </member>
        <member name="F:Sax.Net.Helpers.NamespaceSupport.Context.DeclsOK">
            Create the root-level Namespace context.
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.Context.SetParent(Sax.Net.Helpers.NamespaceSupport.Context)">
             (Re)set the parent of this Namespace context.
             The context must either have been freshly constructed,
             or must have been cleared.
            
             @param context The parent Namespace context object.
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.Context.Clear">
            Makes associated state become collectible,
            invalidating this context.
            {@link #setParent} must be called before
            this context may be used again.
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.Context.DeclarePrefix(System.String,System.String)">
             Declare a Namespace prefix for this context.
            
             @param prefix The prefix to declare.
             @param uri The associated Namespace URI.
             @see org.xml.sax.helpers.NamespaceSupport#declarePrefix
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.Context.ProcessName(System.String,System.Boolean,System.Boolean)">
             Process an XML qualified name in this context.
            
             @param qName The XML qualified name.
             @param isAttribute true if this is an attribute name.
             @return An array of three strings containing the
                     URI part (or empty string), the local part,
                     and the raw name, all internalized, or null
                     if there is an undeclared prefix.
             @see org.xml.sax.helpers.NamespaceSupport#processName
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.Context.GetURI(System.String)">
             Look up the URI associated with a prefix in this context.
            
             @param prefix The prefix to look up.
             @return The associated Namespace URI, or null if none is
                     declared.	
             @see org.xml.sax.helpers.NamespaceSupport#getURI
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.Context.GetPrefix(System.String)">
             Look up one of the prefixes associated with a URI in this context.
            
             <p>Since many prefixes may be mapped to the same URI,
             the return value may be unreliable.</p>
            
             @param uri The URI to look up.
             @return The associated prefix, or null if none is declared.
             @see org.xml.sax.helpers.NamespaceSupport#getPrefix
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.Context.GetDeclaredPrefixes">
             Return an enumeration of prefixes declared in this context.
            
             @return An enumeration of prefixes (possibly empty).
             @see org.xml.sax.helpers.NamespaceSupport#getDeclaredPrefixes
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.Context.GetPrefixes">
             Return an enumeration of all prefixes currently in force.
            
             <p>The default prefix, if in force, is <em>not</em>
             returned, and will have to be checked for separately.</p>
            
             @return An enumeration of prefixes (never empty).
             @see org.xml.sax.helpers.NamespaceSupport#getPrefixes
        </member>
        <member name="M:Sax.Net.Helpers.NamespaceSupport.Context.CopyTables">
             Copy on write for the internal tables in this context.
            
             <p>This class is optimized for the normal case where most
             elements do not contain Namespace declarations.</p>
        </member>
        <member name="T:Sax.Net.Helpers.XmlFilter">
            <summary>
              Base class for deriving an XML filter.
              <blockquote>
                <em>
                  This module, both source code and documentation, is in the
                  Public Domain, and comes with <strong>NO WARRANTY</strong>.
                </em>
                See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                for further information.
              </blockquote>
              <para>
                This class is designed to sit between an <see cref="T:Sax.Net.IXmlReader" />
                and the client application's event handlers.  By default, it
                does nothing but pass requests up to the reader and events
                on to the handlers unmodified, but subclasses can override
                specific methods to modify the event stream or the configuration
                requests as they pass through.
              </para>
            </summary>
            <seealso cref="T:Sax.Net.IXmlFilter" />
            <seealso cref="T:Sax.Net.IXmlReader" />
            <seealso cref="T:Sax.Net.IEntityResolver" />
            <seealso cref="T:Sax.Net.IDTDHandler" />
            <seealso cref="T:Sax.Net.IContentHandler" />
            <seealso cref="T:Sax.Net.IErrorHandler" />
        </member>
        <member name="M:Sax.Net.Helpers.XmlFilter.#ctor">
            <summary>
              Construct an empty XML filter, with no parent.
              <para>
                This filter will have no parent: you must assign a parent
                before you start a parse or do any configuration with
                setFeature or setProperty, unless you use this as a pure event
                consumer rather than as an <see cref="T:Sax.Net.IXmlReader" />.
              </para>
            </summary>
            <seealso cref="M:Sax.Net.IXmlReader.SetFeature(System.String,System.Boolean)" />
            <seealso cref="M:Sax.Net.IXmlReader.SetProperty(System.String,System.Object)" />
            <seealso cref="P:Sax.Net.Helpers.XmlFilter.Parent" />
        </member>
        <member name="M:Sax.Net.Helpers.XmlFilter.#ctor(Sax.Net.IXmlReader)">
            <summary>
              Construct an XML filter with the specified parent.
            </summary>
            <param name="parent">The parent</param>
            <seealso cref="P:Sax.Net.Helpers.XmlFilter.Parent" />
        </member>
        <member name="M:Sax.Net.Helpers.XmlFilter.Parse(Sax.Net.InputSource)">
            <summary>
              Parse an XML document.
              <para>
                The application can use this method to instruct the XML
                reader to begin parsing an XML document from any valid input
                source (a character stream, a byte stream, or a URI).
              </para>
              <para>
                Applications may not invoke this method while a parse is in
                progress (they should create a new XMLReader instead for each
                nested XML document).  Once a parse is complete, an
                application may reuse the same XMLReader object, possibly with a
                different input source.
                Configuration of the XMLReader object (such as handler bindings and
                values established for feature flags and properties) is unchanged
                by completion of a parse, unless the definition of that aspect of
                the configuration explicitly specifies other behavior.
                (For example, feature flags or properties exposing
                characteristics of the document being parsed.)
              </para>
              <para>
                During the parse, the XMLReader will provide information
                about the XML document through the registered event
                handlers.
              </para>
              <para>
                This method is synchronous: it will not return until parsing
                has ended.  If a client application wants to terminate
                parsing early, it should throw an exception.
              </para>
            </summary>
            <param name="input">
              The input source for the top-level of the
              XML document.
            </param>
            <exception cref="T:Sax.Net.SAXException">
              Any SAX exception, possibly
              wrapping another exception.
            </exception>
            <exception cref="!:IOException">
              An IO exception from the parser,
              possibly from a byte stream or character stream
              supplied by the application.
            </exception>
            <seealso cref="T:Sax.Net.InputSource" />
            <seealso cref="M:Sax.Net.Helpers.XmlFilter.Parse(System.String)" />
            <seealso cref="P:Sax.Net.Helpers.XmlFilter.EntityResolver" />
            <seealso cref="P:Sax.Net.Helpers.XmlFilter.DTDHandler" />
            <seealso cref="P:Sax.Net.Helpers.XmlFilter.ContentHandler" />
            <seealso cref="P:Sax.Net.Helpers.XmlFilter.ErrorHandler" />
        </member>
        <member name="M:Sax.Net.Helpers.XmlFilter.Parse(System.String)">
            <summary>
              Parse a document.
            </summary>
            <param name="systemId">
              The system identifier as a fully-qualified URI.
            </param>
            <exception cref="T:Sax.Net.SAXException">
              Any SAX exception, possibly
              wrapping another exception.
            </exception>
            <exception cref="!:IOException">
              An IO exception from the parser,
              possibly from a byte stream or character stream
              supplied by the application.
            </exception>
        </member>
        <member name="M:Sax.Net.Helpers.XmlFilter.SetupParse">
            <summary>
              Set up before a parse.
              <para>
                Before every parse, check whether the parent is
                non-null, and re-register the filter for all of the
                events.
              </para>
            </summary>
        </member>
        <member name="T:Sax.Net.Helpers.XmlReaderFactory">
            <summary>
                Factory for creating an XML reader.
                <blockquote>
                    <em>
                        This module, both source code and documentation, is in the
                        Public Domain, and comes with <strong>NO WARRANTY</strong>.
                    </em>
                    See <a href='http://www.saxproject.org'>http://www.saxproject.org</a>
                    for further information.
                </blockquote>
                <para>
                    This class contains static methods for creating an XML reader
                    from an explicit class name, or based on runtime defaults:
                </para>
                <code>
                try {
                IXmlReader myReader = XmlReaderFactory.CreateXmlReader();
                } catch (SAXException ex) {
                  Console.WriteLine(ex.ToString());
                }
              </code>
            </summary>
        </member>
        <member name="P:Sax.Net.Helpers.XmlReaderFactory.Current">
            <summary>
                Gets the Current <see cref="T:Sax.Net.Helpers.IXmlReaderFactory" />
            </summary>
        </member>
        <member name="M:Sax.Net.Helpers.XmlReaderFactory.SetCurrent(System.Func{Sax.Net.Helpers.IXmlReaderFactory})">
            <summary>
                Sets the Current <see cref="T:Sax.Net.Helpers.IXmlReaderFactory" />
            </summary>
            <param name="factory">The factory</param>
        </member>
        <member name="M:Sax.Net.SaxDriver.#ctor">
            <summary>
              Constructs a SAX Parser.
            </summary>
        </member>
        <member name="P:Sax.Net.SaxDriver.Length">
            <summary>
              IAttributes method (don't invoke on parser);
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetUri(System.Int32)">
            <summary>
              IAttributes method (don't invoke on parser);
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetLocalName(System.Int32)">
            <summary>
              IAttributes method (don't invoke on parser);
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetQName(System.Int32)">
            <summary>
              IAttributes method (don't invoke on parser);
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetType(System.Int32)">
            <summary>
              IAttributes method (don't invoke on parser);
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetValue(System.Int32)">
            <summary>
              IAttributes method (don't invoke on parser);
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetIndex(System.String,System.String)">
            <summary>
              IAttributes method (don't invoke on parser);
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetIndex(System.String)">
            <summary>
              IAttributes method (don't invoke on parser);
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetType(System.String,System.String)">
            <summary>
              IAttributes method (don't invoke on parser);
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetType(System.String)">
            <summary>
              IAttributes method (don't invoke on parser);
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetValue(System.String,System.String)">
            <summary>
              IAttributes method (don't invoke on parser);
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetValue(System.String)">
            <summary>
              IAttributes method (don't invoke on parser);
            </summary>
        </member>
        <member name="P:Sax.Net.SaxDriver.PublicId">
            <summary>
              ILocator method (don't invoke on parser);
            </summary>
        </member>
        <member name="P:Sax.Net.SaxDriver.SystemId">
            <summary>
              ILocator method (don't invoke on parser);
            </summary>
        </member>
        <member name="P:Sax.Net.SaxDriver.LineNumber">
            <summary>
              ILocator method (don't invoke on parser);
            </summary>
        </member>
        <member name="P:Sax.Net.SaxDriver.ColumnNumber">
            <summary>
              ILocator method (don't invoke on parser);
            </summary>
        </member>
        <member name="P:Sax.Net.SaxDriver.EntityResolver">
            <summary>
              Returns the object used when resolving external
              entities during parsing (both general and parameter entities).
            </summary>
        </member>
        <member name="P:Sax.Net.SaxDriver.DTDHandler">
            <summary>
              Returns the object used to process declarations related
              to notations and unparsed entities.
            </summary>
        </member>
        <member name="P:Sax.Net.SaxDriver.ContentHandler">
            <summary>
              Returns the object used to report the logical
              content of an XML document.
            </summary>
        </member>
        <member name="P:Sax.Net.SaxDriver.ErrorHandler">
            <summary>
              Returns the object used to receive callbacks for XML
              errors of all levels (fatal, nonfatal, warning); this is never null;
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.Sax#Net#IXmlReader#Parse(Sax.Net.InputSource)">
            <summary>
              Auxiliary API to parse an XML document, used mostly
              when no URI is available.
              If you want anything useful to happen, you should set
              at least one type of handler.
            </summary>
            <param name="source">
              The XML input source.  Don't set 'encoding' unless
              you know for a fact that it's correct.
            </param>
            <seealso cref="P:Sax.Net.SaxDriver.EntityResolver" />
            <seealso cref="P:Sax.Net.SaxDriver.DTDHandler" />
            <seealso cref="P:Sax.Net.SaxDriver.ContentHandler" />
            <seealso cref="P:Sax.Net.SaxDriver.ErrorHandler" />
            <exception cref="T:Sax.Net.SAXException">
              The handlers may throw any SAXException,
              and the parser normally throws SAXParseException objects.
            </exception>
            <exception cref="T:System.IO.IOException">
              IOExceptions are normally through through
              the parser if there are problems reading the source document.
            </exception>
        </member>
        <member name="M:Sax.Net.SaxDriver.Parse(System.String)">
            <summary>
              Preferred API to parse an XML document, using a
              system identifier (URI).
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetFeature(System.String)">
            <summary>
              Tells the value of the specified feature flag.
            </summary>
            <exception cref="T:Sax.Net.SAXNotRecognizedException">
              thrown if the feature flag
              is neither built in, nor yet assigned.
            </exception>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetProperty(System.String)">
            <summary>
               Returns the specified property.
            </summary>
            <exception cref="T:Sax.Net.SAXNotRecognizedException">
              thrown if the property value
              is neither built in, nor yet stored.
            </exception>
        </member>
        <member name="M:Sax.Net.SaxDriver.SetFeature(System.String,System.Boolean)">
            <summary>
               Returns the specified property.
            </summary>
            <exception cref="T:Sax.Net.SAXNotRecognizedException">
              thrown if the property value
              is neither built in, nor yet stored.
            </exception>
        </member>
        <member name="M:Sax.Net.SaxDriver.SetProperty(System.String,System.Object)">
            <summary>
               Assigns the specified property.  Like SAX1 handlers,
              these may be changed at any time.
            </summary>
        </member>
        <member name="M:Sax.Net.SaxDriver.GetName(System.Int32)">
            <summary>
              IAttributes method (don't invoke on parser);
            </summary>
        </member>
        <member name="T:Sax.Net.XmlParser">
            <summary>
              Parse XML documents and return parse events through call-backs.
              Use the <c>SAXDriver</c> class as your entry point, as the
              internal parser interfaces are subject to change.
            </summary>
            <seealso cref="!:SAXDriver" />
        </member>
        <member name="M:Sax.Net.XmlParser.#ctor">
            Construct a new parser with no associated handler.
            @see #setHandler
            @see #parse
        </member>
        <member name="M:Sax.Net.XmlParser.setHandler(Sax.Net.SaxDriver)">
            Set the handler that will receive parsing events.
            @param handler The handler to receive callback events.
            @see #parse
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.DoParse(System.String,System.String,System.IO.TextReader,System.IO.Stream,System.Text.Encoding)" -->
        <member name="F:Sax.Net.XmlParser.CONTENT_UNDECLARED">
            Constant: an element has not been declared.
            @see #getElementContentType
        </member>
        <member name="F:Sax.Net.XmlParser.CONTENT_ANY">
            Constant: the element has a content model of ANY.
            @see #getElementContentType
        </member>
        <member name="F:Sax.Net.XmlParser.CONTENT_EMPTY">
            Constant: the element has declared content of EMPTY.
            @see #getElementContentType
        </member>
        <member name="F:Sax.Net.XmlParser.CONTENT_MIXED">
            Constant: the element has mixed content.
            @see #getElementContentType
        </member>
        <member name="F:Sax.Net.XmlParser.CONTENT_ELEMENTS">
            Constant: the element has element content.
            @see #getElementContentType
        </member>
        <member name="F:Sax.Net.XmlParser.ENTITY_UNDECLARED">
            Constant: the entity has not been declared.
            @see #getEntityType
        </member>
        <member name="F:Sax.Net.XmlParser.ENTITY_INTERNAL">
            Constant: the entity is internal.
            @see #getEntityType
        </member>
        <member name="F:Sax.Net.XmlParser.ENTITY_NDATA">
            Constant: the entity is external, non-parseable data.
            @see #getEntityType
        </member>
        <member name="F:Sax.Net.XmlParser.ENTITY_TEXT">
            Constant: the entity is external XML data.
            @see #getEntityType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_UNDECLARED">
            Constant: the attribute has not been declared for this element type.
            @see #getAttributeType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_CDATA">
            Constant: the attribute value is a string value.
            @see #getAttributeType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_ID">
            Constant: the attribute value is a unique identifier.
            @see #getAttributeType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_IDREF">
            Constant: the attribute value is a reference to a unique identifier.
            @see #getAttributeType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_IDREFS">
            Constant: the attribute value is a list of ID references.
            @see #getAttributeType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_ENTITY">
            Constant: the attribute value is the name of an entity.
            @see #getAttributeType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_ENTITIES">
            Constant: the attribute value is a list of entity names.
            @see #getAttributeType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_NMTOKEN">
            Constant: the attribute value is a name token.
            @see #getAttributeType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_NMTOKENS">
            Constant: the attribute value is a list of name tokens.
            @see #getAttributeType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_ENUMERATED">
            Constant: the attribute value is a token from an enumeration.
            @see #getAttributeType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_NOTATION">
            Constant: the attribute is the name of a notation.
            @see #getAttributeType
        </member>
        <member name="F:Sax.Net.XmlParser.attributeTypeHash">
            Hash table of attribute types.
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_DEFAULT_UNDECLARED">
            Constant: the attribute is not declared.
            @see #getAttributeDefaultValueType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_DEFAULT_SPECIFIED">
            Constant: the attribute has a literal default value specified.
            @see #getAttributeDefaultValueType
            @see #getAttributeDefaultValue
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_DEFAULT_IMPLIED">
            Constant: the attribute was declared #IMPLIED.
            @see #getAttributeDefaultValueType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_DEFAULT_REQUIRED">
            Constant: the attribute was declared #REQUIRED.
            @see #getAttributeDefaultValueType
        </member>
        <member name="F:Sax.Net.XmlParser.ATTRIBUTE_DEFAULT_FIXED">
            Constant: the attribute was declared #FIXED.
            @see #getAttributeDefaultValueType
            @see #getAttributeDefaultValue
        </member>
        <member name="M:Sax.Net.XmlParser.error(System.String,System.String,System.String)">
            Report an error.
            @param message The error message.
            @param textFound The text that caused the error (or null).
            @see SAXDriver#error
            @see #line
        </member>
        <member name="M:Sax.Net.XmlParser.error(System.String,System.Char,System.String)">
            Report a serious error.
            @param message The error message.
            @param textFound The text that caused the error (or null).
        </member>
        <member name="M:Sax.Net.XmlParser.error(System.String)">
            Report typical case fatal errors. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseDocument" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseComment" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parsePI" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseCDSect" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseProlog" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseXMLDecl(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseTextDecl(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.setupDecoding(System.Text.Encoding)" -->
        <member name="M:Sax.Net.XmlParser.parseMisc">
            Parse miscellaneous markup outside the document element and DOCTYPE
            declaration.
            <pre>
            [27] Misc ::= Comment | PI | S
            </pre>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseDoctypedecl" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseMarkupdecl" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseElement" -->
        <member name="M:Sax.Net.XmlParser.parseAttribute(System.String)">
            Parse an attribute assignment.
            <pre>
            [41] Attribute ::= Name Eq AttValue
            </pre>
            @param name The name of the attribute's element.
            @see SAXDriver#attribute
        </member>
        <member name="M:Sax.Net.XmlParser.parseEq">
            Parse an Equals sign surrounded by optional whitespace.
            <pre>
            [25] Eq ::= S? '=' S?
            </pre>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseETag" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseContent" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseElementdecl" -->
        <member name="M:Sax.Net.XmlParser.parseContentspec(System.String)">
            Content specification.
            <pre>
            [46] contentspec ::= 'EMPTY' | 'ANY' | Mixed | elements
            </pre>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseElements" -->
        <member name="M:Sax.Net.XmlParser.parseCp">
            Parse a content particle.
            <pre>
            [48] cp ::= (Name | choice | seq) ('?' | '*' | '+')?
            </pre>
        </member>
        <member name="M:Sax.Net.XmlParser.parseMixed">
            Parse mixed content.
            <pre>
            [51] Mixed ::= '(' S? ( '#PCDATA' (S? '|' S? Name)*) S? ')*'
                   | '(' S? ('#PCDATA') S? ')'
            </pre>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseAttlistDecl" -->
        <member name="M:Sax.Net.XmlParser.parseAttDef(System.String)">
            Parse a single attribute definition.
            <pre>
            [53] AttDef ::= S Name S AttType S DefaultDecl
            </pre>
        </member>
        <member name="M:Sax.Net.XmlParser.readAttType">
            Parse the attribute type.
            <pre>
            [54] AttType ::= StringType | TokenizedType | EnumeratedType
            [55] StringType ::= 'CDATA'
            [56] TokenizedType ::= 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY'
                 | 'ENTITIES' | 'NMTOKEN' | 'NMTOKENS'
            [57] EnumeratedType ::= NotationType | Enumeration
            </pre>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseEnumeration(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseNotationType" -->
        <member name="M:Sax.Net.XmlParser.parseDefault(System.String,System.String,System.Int32,System.String)">
            Parse the default value for an attribute.
            <pre>
            [60] DefaultDecl ::= '#REQUIRED' | '#IMPLIED'
                 | (('#FIXED' S)? AttValue)
            </pre>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseConditionalSect" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseCharRef" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseEntityRef(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parsePEReference" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseEntityDecl" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseNotationDecl" -->
        <member name="M:Sax.Net.XmlParser.parseCharData">
            Parse character data.
            <pre>
            [14] CharData ::= [^&lt;&amp;]* - ([^&lt;&amp;]* ']]&gt;' [^&lt;&amp;]*)
            </pre>
        </member>
        <member name="M:Sax.Net.XmlParser.requireWhitespace">
            Require whitespace characters.
        </member>
        <member name="M:Sax.Net.XmlParser.parseWhitespace">
            Parse whitespace characters, and leave them in the data buffer.
        </member>
        <member name="M:Sax.Net.XmlParser.skipWhitespace">
            Skip whitespace characters.
            <pre>
            [3] S ::= (#x20 | #x9 | #xd | #xa)+
            </pre>
        </member>
        <member name="M:Sax.Net.XmlParser.readNmtoken(System.Boolean)">
            Read a name or (when parsing an enumeration) name token.
            <pre>
            [5] Name ::= (Letter | '_' | ':') (NameChar)*
            [7] Nmtoken ::= (NameChar)+
            </pre>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.readLiteral(System.Int32)" -->
        <member name="M:Sax.Net.XmlParser.readExternalIds(System.Boolean)">
            Try reading external identifiers.
            A system identifier is not required for notations.
            @param inNotation Are we in a notation?
            @return A two-member string array containing the identifiers.
        </member>
        <member name="M:Sax.Net.XmlParser.isWhitespace(System.Char)">
            Test if a character is whitespace.
            <pre>
            [3] S ::= (#x20 | #x9 | #xd | #xa)+
            </pre>
            @param c The character to test.
            @return true if the character is whitespace.
        </member>
        <member name="M:Sax.Net.XmlParser.dataBufferAppend(System.Char)">
            Add a character to the data buffer.
        </member>
        <member name="M:Sax.Net.XmlParser.dataBufferAppend(System.String)">
            Add a string to the data buffer.
        </member>
        <member name="M:Sax.Net.XmlParser.dataBufferAppend(System.Char[],System.Int32,System.Int32)">
            Append (part of) a character array to the data buffer.
        </member>
        <member name="M:Sax.Net.XmlParser.dataBufferNormalize">
            Normalise spaces in the data buffer.
        </member>
        <member name="M:Sax.Net.XmlParser.dataBufferToString">
            Convert the data buffer to a string.
        </member>
        <member name="M:Sax.Net.XmlParser.dataBufferFlush">
            Flush the contents of the data buffer to the handler, as
            appropriate, and reset the buffer for new input.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.require(System.String,System.String)" -->
        <member name="M:Sax.Net.XmlParser.require(System.Char,System.String)">
            Require a character to appear, or throw an exception.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.intern(System.Char[],System.Int32,System.Int32)" -->
        <member name="M:Sax.Net.XmlParser.extendArray(System.Object,System.Int32,System.Int32)">
            Ensure the capacity of an array, allocating a new one if
            necessary.  Usually called only a handful of times.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.declaredElements" -->
        <member name="M:Sax.Net.XmlParser.getContentType(System.Object[],System.Int32)">
            Look up the content type of an element.
            @param element element info vector
            @param defaultType value for null vector
            @return An integer constant representing the content type.
            @see #CONTENT_UNDECLARED
            @see #CONTENT_ANY
            @see #CONTENT_EMPTY
            @see #CONTENT_MIXED
            @see #CONTENT_ELEMENTS
        </member>
        <member name="M:Sax.Net.XmlParser.getElementContentType(System.String)">
            Look up the content type of an element.
            @param name The element type name.
            @return An integer constant representing the content type.
            @see #getElementContentModel
            @see #CONTENT_UNDECLARED
            @see #CONTENT_ANY
            @see #CONTENT_EMPTY
            @see #CONTENT_MIXED
            @see #CONTENT_ELEMENTS
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.getElementContentModel(System.String)" -->
        <member name="M:Sax.Net.XmlParser.setElement(System.String,System.Int32,System.String,System.Collections.Hashtable)">
            Register an element.
            Array format:
             [0] element type name
             [1] content model (mixed, elements only)
             [2] attribute hash table
        </member>
        <member name="M:Sax.Net.XmlParser.getElementAttributes(System.String)">
            Look up the attribute hash table for an element.
            The hash table is the second item in the element array.
        </member>
        <member name="M:Sax.Net.XmlParser.declaredAttributes(System.Object[])">
            Get the declared attributes for an element type.
            @param elname The name of the element type.
            @return An Enumeration of all the attributes declared for
              a specific element type.  The results will be valid only
              after the DTD (if any) has been parsed.
            @see #getAttributeType
            @see #getAttributeEnumeration
            @see #getAttributeDefaultValueType
            @see #getAttributeDefaultValue
            @see #getAttributeExpandedValue
        </member>
        <member name="M:Sax.Net.XmlParser.declaredAttributes(System.String)">
            Get the declared attributes for an element type.
            @param elname The name of the element type.
            @return An Enumeration of all the attributes declared for
              a specific element type.  The results will be valid only
              after the DTD (if any) has been parsed.
            @see #getAttributeType
            @see #getAttributeEnumeration
            @see #getAttributeDefaultValueType
            @see #getAttributeDefaultValue
            @see #getAttributeExpandedValue
        </member>
        <member name="M:Sax.Net.XmlParser.getAttributeType(System.String,System.String)">
            Retrieve the declared type of an attribute.
            @param name The name of the associated element.
            @param aname The name of the attribute.
            @return An integer constant representing the attribute type.
            @see #ATTRIBUTE_UNDECLARED
            @see #ATTRIBUTE_CDATA
            @see #ATTRIBUTE_ID
            @see #ATTRIBUTE_IDREF
            @see #ATTRIBUTE_IDREFS
            @see #ATTRIBUTE_ENTITY
            @see #ATTRIBUTE_ENTITIES
            @see #ATTRIBUTE_NMTOKEN
            @see #ATTRIBUTE_NMTOKENS
            @see #ATTRIBUTE_ENUMERATED
            @see #ATTRIBUTE_NOTATION
        </member>
        <member name="M:Sax.Net.XmlParser.getAttributeEnumeration(System.String,System.String)">
            Retrieve the allowed values for an enumerated attribute type.
            @param name The name of the associated element.
            @param aname The name of the attribute.
            @return A string containing the token list.
            @see #ATTRIBUTE_ENUMERATED
            @see #ATTRIBUTE_NOTATION
        </member>
        <member name="M:Sax.Net.XmlParser.getAttributeDefaultValue(System.String,System.String)">
            Retrieve the default value of a declared attribute.
            @param name The name of the associated element.
            @param aname The name of the attribute.
            @return The default value, or null if the attribute was
              #IMPLIED or simply undeclared and unspecified.
            @see #getAttributeExpandedValue
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.getAttributeExpandedValue(System.String,System.String)" -->
        <member name="M:Sax.Net.XmlParser.getAttributeDefaultValueType(System.String,System.String)">
            Retrieve the default value type of a declared attribute.
            @see #ATTRIBUTE_DEFAULT_SPECIFIED
            @see #ATTRIBUTE_DEFAULT_IMPLIED
            @see #ATTRIBUTE_DEFAULT_REQUIRED
            @see #ATTRIBUTE_DEFAULT_FIXED
        </member>
        <member name="M:Sax.Net.XmlParser.setAttribute(System.String,System.String,System.Int32,System.String,System.String,System.Int32)">
            Register an attribute declaration for later retrieval.
            Format:
            - String type
            - String default value
            - int value type
        </member>
        <member name="M:Sax.Net.XmlParser.getAttribute(System.String,System.String)">
            Retrieve the five-member array representing an
            attribute declaration.
        </member>
        <member name="M:Sax.Net.XmlParser.declaredEntities">
            Get declared entities.
            @return An Enumeration of all the entities declared for
              this XML document.  The results will be valid only
              after the DTD (if any) has been parsed.
            @see #getEntityType
            @see #getEntityPublicId
            @see #getEntitySystemId
            @see #getEntityValue
            @see #getEntityNotationName
        </member>
        <member name="M:Sax.Net.XmlParser.getEntityType(System.String)">
            Find the type of an entity.
            @returns An integer constant representing the entity type.
            @see #ENTITY_UNDECLARED
            @see #ENTITY_INTERNAL
            @see #ENTITY_NDATA
            @see #ENTITY_TEXT
        </member>
        <member name="M:Sax.Net.XmlParser.getEntityPublicId(System.String)">
            Return an external entity's public identifier, if any.
            @param ename The name of the external entity.
            @return The entity's system identifier, or null if the
              entity was not declared, if it is not an
              external entity, or if no public identifier was
              provided.
            @see #getEntityType
        </member>
        <member name="M:Sax.Net.XmlParser.getEntitySystemId(System.String)">
            Return an external entity's system identifier.
            @param ename The name of the external entity.
            @return The entity's system identifier, or null if the
              entity was not declared, or if it is not an
              external entity. Change made by MHK: The system identifier
              is returned as an absolute URL, resolved relative to the entity
              it was contained in.
            @see #getEntityType
        </member>
        <member name="M:Sax.Net.XmlParser.getEntityValue(System.String)">
            Return the value of an internal entity.
            @param ename The name of the internal entity.
            @return The entity's value, or null if the entity was
              not declared, or if it is not an internal entity.
            @see #getEntityType
        </member>
        <member name="M:Sax.Net.XmlParser.getEntityNotationName(System.String)">
            Get the notation name associated with an NDATA entity.
            @param ename The NDATA entity name.
            @return The associated notation name, or null if the
              entity was not declared, or if it is not an
              NDATA entity.
            @see #getEntityType
        </member>
        <member name="M:Sax.Net.XmlParser.setInternalEntity(System.String,System.String)">
            Register an entity declaration for later retrieval.
        </member>
        <member name="M:Sax.Net.XmlParser.setExternalDataEntity(System.String,System.String,System.String,System.String)">
            Register an external data entity.
        </member>
        <member name="M:Sax.Net.XmlParser.setExternalTextEntity(System.String,System.String,System.String)">
            Register an external text entity.
        </member>
        <member name="M:Sax.Net.XmlParser.setEntity(System.String,System.Int32,System.String,System.String,System.String,System.String)">
            Register an entity declaration for later retrieval.
        </member>
        <member name="M:Sax.Net.XmlParser.declaredNotations">
            Get declared notations.
            @return An Enumeration of all the notations declared for
              this XML document.  The results will be valid only
              after the DTD (if any) has been parsed.
            @see #getNotationPublicId
            @see #getNotationSystemId
        </member>
        <member name="M:Sax.Net.XmlParser.getNotationPublicId(System.String)">
            Look up the public identifier for a notation.
            You will normally use this method to look up a notation
            that was provided as an attribute value or for an NDATA entity.
            @param nname The name of the notation.
            @return A string containing the public identifier, or null
              if none was provided or if no such notation was
              declared.
            @see #getNotationSystemId
        </member>
        <member name="M:Sax.Net.XmlParser.getNotationSystemId(System.String)">
            Look up the system identifier for a notation.
            You will normally use this method to look up a notation
            that was provided as an attribute value or for an NDATA entity.
            @param nname The name of the notation.
            @return A string containing the system identifier, or null
              if no such notation was declared.
            @see #getNotationPublicId
        </member>
        <member name="M:Sax.Net.XmlParser.setNotation(System.String,System.String,System.String)">
            Register a notation declaration for later retrieval.
            Format:
            - public id
            - system id
        </member>
        <member name="P:Sax.Net.XmlParser.LineNumber">
            Return the current line number.
        </member>
        <member name="P:Sax.Net.XmlParser.ColumnNumber">
            Return the current column number.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.readCh" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.unread(System.Char)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.unread(System.Char[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.pushURL(System.String,System.String,System.String,System.IO.TextReader,System.IO.Stream,System.Text.Encoding,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.tryEncodingDecl(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.detectEncoding" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.tryEncoding(System.Byte[],System.Byte,System.Byte,System.Byte,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.tryEncoding(System.Byte[],System.Byte,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.tryEncoding(System.Byte[],System.Byte,System.Byte,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.pushString(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.pushCharArray(System.String,System.Char[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.pushInput(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.popInput" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.tryRead(System.Char)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.tryRead(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.tryWhitespace" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.parseUntil(System.String)" -->
        <member name="M:Sax.Net.XmlParser.read8bitEncodingDeclaration">
            Read just the encoding declaration (or XML declaration) at the 
            start of an external entity.
            When this method is called, we know that the declaration is
            present (or appears to be).  We also know that the entity is
            in some sort of ASCII-derived 8-bit encoding.
            The idea of this is to let us read what the 8-bit encoding is
            before we've committed to converting any more of the file; the
            XML or encoding declaration must be in 7-bit ASCII, so we're
            safe as long as we don't go past it.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.readDataChunk" -->
        <member name="M:Sax.Net.XmlParser.filterCR(System.Boolean)">
            Filter carriage returns in the read buffer.
            CRLF becomes LF; CR becomes LF.
            @param moreData true iff more data might come from the same source
            @see #readDataChunk
            @see #readBuffer
            @see #readBufferOverflow
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.copyUtf8ReadBuffer(System.Int32)" -->
        <member name="M:Sax.Net.XmlParser.getNextUtf8Byte(System.Int32,System.Int32)">
            Return the next byte value in a UTF-8 sequence.
            If it is not possible to get a byte from the current
            entity, throw an exception.
            @param pos The current position in the rawReadBuffer.
            @param count The number of bytes in the rawReadBuffer
            @return The significant six bits of a non-initial byte in
              a UTF-8 sequence.
            @exception EOFException If the sequence is incomplete.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.copyIso8859_1ReadBuffer(System.Int32,System.Char)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.copyUcs2ReadBuffer(System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Sax.Net.XmlParser.copyUcs4ReadBuffer(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <member name="M:Sax.Net.XmlParser.encodingError(System.String,System.Int32,System.Int32)">
            Report a character encoding error.
        </member>
        <member name="M:Sax.Net.XmlParser.initializeVariables">
            Re-initialize the variables for each parse.
        </member>
        <member name="M:Sax.Net.XmlParser.cleanupVariables">
            Clean up after the parse to allow some garbage collection.
        </member>
        <member name="M:Sax.Net.CharConversionException.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class.
            </summary>
        </member>
        <member name="M:Sax.Net.CharConversionException.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:Sax.Net.CharConversionException.#ctor(System.String,System.Exception)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message and a
              reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception. </param>
            <param name="innerException">
              The exception that is the cause of the current exception, or a null reference (Nothing in
              Visual Basic) if no inner exception is specified.
            </param>
        </member>
        <member name="M:Sax.Net.CharConversionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:System.Exception" /> class with serialized data.
            </summary>
            <param name="info">
              The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
              data about the exception being thrown.
            </param>
            <param name="context">
              The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
              information about the source or destination.
            </param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
              The class name is null or
              <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
        </member>
    </members>
</doc>
